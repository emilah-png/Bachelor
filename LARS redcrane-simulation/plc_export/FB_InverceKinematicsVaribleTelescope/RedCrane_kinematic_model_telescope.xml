<?xml version="1.0" encoding="UTF-8"?>
<project>
  <!--(*
 *
 * File: RedCrane_kinematic_model_telescope.xml
 *
 * IEC 61131-3 Structured Text (ST) code generated for subsystem "RedCrane_kinematic_model_telescope/FB_InverceKinematicsVaribleTelescope"
 *
 * Model name                      : RedCrane_kinematic_model_telescope
 * Model version                   : 2.94
 * Model creator                   : sindr
 * Model last modified by          : larso
 * Model last modified on          : Tue Jan 28 15:09:52 2025
 * Model sample time               : 0.001s
 * Subsystem name                  : RedCrane_kinematic_model_telescope/FB_InverceKinematicsVaribleTelescope
 * Subsystem sample time           : 0.001s
 * Simulink PLC Coder version      : 24.1 (R2024a) 19-Nov-2023
 * ST code generated on            : Tue Jan 28 15:11:03 2025
 *
 * Target IDE selection            : Beckhoff TwinCAT 3
 * Test Bench included             : No
 *
 *)
-->
  <fileHeader companyName="The Mathworks, Inc." companyURL="www.mathworks.com" contentDescription="" creationDateTime="2025-01-28T15:11:03" productName="Simulink PLC Coder" productRelease="(R2024a)" productVersion="24.1"/>
  <contentHeader name="RedCrane_kinematic_model_telescope">
    <coordinateInfo>
      <fbd>
        <scaling x="0" y="0"/>
      </fbd>
      <ld>
        <scaling x="0" y="0"/>
      </ld>
      <sfc>
        <scaling x="0" y="0"/>
      </sfc>
    </coordinateInfo>
  </contentHeader>
  <types>
    <dataTypes/>
    <pous>
      <pou name="c_FB_InverceKinematicsVarib" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="ssMethodType">
              <type>
                <SINT/>
              </type>
            </variable>
            <variable name="fXRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fYRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fZRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fXDotRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fYDotRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fZDotRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fSlewFeedback">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fMainFeedback">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fKnuckleFeedback">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fTelescopePos">
              <type>
                <LREAL/>
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="fSlewRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fMainRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fKnuckleRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fSlewVelRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fMainVelRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fKnuckleVelRef">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="success">
              <type>
                <BOOL/>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="qs4">
              <type>
                <array>
                  <dimension lower="0" upper="2"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="SList">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="Js">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="M">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="T">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="thetalist0">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="Tsb">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="Vs">
              <type>
                <array>
                  <dimension lower="0" upper="5"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="err">
              <type>
                <BOOL/>
              </type>
            </variable>
            <variable name="b_i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="c_i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="d_i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="e_i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="b_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="se3mat">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="omgmat">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="a">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="g_a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="V">
              <type>
                <array>
                  <dimension lower="0" upper="5"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_R">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_omgmat">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="l_a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="rtb_thetaListDot">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="d_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="g_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="thetalist0_0">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="se3mat_0">
              <type>
                <array>
                  <dimension lower="0" upper="2"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="a_0">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmp">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="Tsb_0">
              <type>
                <array>
                  <dimension lower="0" upper="35"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmp_0">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmp_1">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_T">
              <type>
                <array>
                  <dimension lower="0" upper="15"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmp_2">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmp_3">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmp_4">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="i_0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="omgmat_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="x_tmp">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="R_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="e_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="c_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="f_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="h_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="i_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="j_theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="i0_eye">
              <type>
                <derived name="eye"/>
              </type>
            </variable>
            <variable name="i0_pinv">
              <type>
                <derived name="pinv"/>
              </type>
            </variable>
            <variable name="i0_MatrixLog3">
              <type>
                <derived name="MatrixLog3"/>
              </type>
            </variable>
            <variable name="Memory_PreviousInput">
              <type>
                <array>
                  <dimension lower="0" upper="1"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="Memory1_PreviousInput">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="Memory2_PreviousInput">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="Memory3_PreviousInput">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="g">
              <type>
                <array>
                  <dimension lower="0" upper="14"/>
                  <baseType>
                    <SINT/>
                  </baseType>
                </array>
              </type>
              <initialValue>
                <arrayValue>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="1"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="-1"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="-1"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="1"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="1"/>
                  </value>
                </arrayValue>
              </initialValue>
            </variable>
            <variable name="p_a">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <SINT/>
                  </baseType>
                </array>
              </type>
              <initialValue>
                <arrayValue>
                  <value>
                    <simpleValue value="1"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="1"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="0"/>
                  </value>
                  <value>
                    <simpleValue value="1"/>
                  </value>
                </arrayValue>
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

CASE ssMethodType OF
    SS_INITIALIZE: 
        (* SystemInitialize for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* InitializeConditions for Memory: '<S1>/Memory' *)
        Memory_PreviousInput[0] := 0.0;
        Memory_PreviousInput[1] := 0.0;
        (* InitializeConditions for Memory: '<S1>/Memory1' *)
        Memory1_PreviousInput := -0.39269908169872414;
        (* InitializeConditions for Memory: '<S1>/Memory2' *)
        Memory2_PreviousInput := 0.0;
        (* InitializeConditions for Memory: '<S1>/Memory3' *)
        Memory3_PreviousInput := 0.0;
        (* End of SystemInitialize for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
    SS_STEP: 
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' incorporates:
         *  Memory: '<S1>/Memory'
         *  Memory: '<S1>/Memory1'
         *  Memory: '<S1>/Memory2'
         *  Memory: '<S1>/Memory3' *)
        thetalist0[0] := Memory3_PreviousInput;
        thetalist0[1] := Memory2_PreviousInput;
        thetalist0[2] := Memory1_PreviousInput;
        thetalist0[3] := Memory_PreviousInput[0];
        thetalist0[4] := Memory_PreviousInput[1];
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function 'FB_InverceKinematicsVaribleTelescope/inverceKinematics': '<S2>:1' *)
        (* '<S2>:1:4' if(t <= Ts*1.1) *)
        (* Deffine zero configuration trasform and screw axis with telescope *)
        (* Lengths *)
        (* '<S2>:1:10' L1 = 250/1000; *)
        (* '<S2>:1:11' L2 = 1568.50/1000; *)
        (* '<S2>:1:12' L3 = 69.97/1000; *)
        (* '<S2>:1:13' L4 = 2400/1000; *)
        (* '<S2>:1:14' L5 = 2428.99/1000; *)
        (* '<S2>:1:15' L6 = 92.52/1000; *)
        (* '<S2>:1:16' L7 = 336.2/1000; *)
        (* Adjusting L5 based on telescope extention: *)
        (* '<S2>:1:19' L5 = L5 + xTele; *)
        (* zero configuration trasform *)
        (* '<S2>:1:22' M = [1, 0, 0, (L5 + L4 - L1); *)
        (* '<S2>:1:23'     0, 1, 0 (L7); *)
        (* '<S2>:1:24'     0, 0, 1, (L2+ L3 - L6); *)
        (* '<S2>:1:25'     0, 0, 0, 1]; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        M[0] := 1.0;
        M[4] := 0.0;
        M[8] := 0.0;
        M[12] := ((fTelescopePos + 2.4289899999999998) + 2.4) - 0.25;
        M[1] := 0.0;
        M[2] := 0.0;
        M[3] := 0.0;
        M[5] := 1.0;
        M[6] := 0.0;
        M[7] := 0.0;
        M[9] := 0.0;
        M[10] := 1.0;
        M[11] := 0.0;
        M[13] := 0.3362;
        M[14] := 1.5459500000000002;
        M[15] := 1.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* screw axis *)
        (* '<S2>:1:28' ws1 = [0, 0, 1]'; *)
        (* '<S2>:1:29' ws2 = [0, -1, 0]'; *)
        (* '<S2>:1:30' ws3 = [0, -1, 0]'; *)
        (* '<S2>:1:31' ws4 = [0, 1, 0]'; *)
        (* '<S2>:1:32' ws5 = [0, 0, 1]'; *)
        (* coordinates of an arbitrary point along the screw axis *)
        (* '<S2>:1:35' qs1 = [0, 0, 0]'; *)
        (* '<S2>:1:36' qs2 = [-L1, 0, L2]'; *)
        (* '<S2>:1:37' qs3 = [(L4 - L1), 0, (L2 + L3)]'; *)
        (* '<S2>:1:38' qs4 = [(L5 + L4 - L1), L7, (L2 + L3 - L6)]'; *)
        (* '<S2>:1:39' qs5 = qs4; *)
        (* Building screw axis matrix *)
        (* '<S2>:1:42' ws_mat = [ws1, ws2, ws3, ws4, ws5]; *)
        (* '<S2>:1:43' vs_mat = [cross(qs1, ws1), cross(qs2, ws2), ... *)
        (* '<S2>:1:44'           cross(qs3, ws3), cross(qs4, ws4), ... *)
        (* '<S2>:1:45'           cross(qs5, ws5)]; *)
        (* '<S2>:1:47' SList = [ws_mat; *)
        (* '<S2>:1:48'     vs_mat]; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 4 DO 
            SList[6 * i_0] := SINT_TO_LREAL(g[3 * i_0]);
            SList[(6 * i_0) + 1] := SINT_TO_LREAL(g[(3 * i_0) + 1]);
            SList[(6 * i_0) + 2] := SINT_TO_LREAL(g[(3 * i_0) + 2]);
        END_FOR;

        SList[3] := 0.0;
        SList[9] := 1.5685;
        SList[15] := 1.63847;
        SList[4] := 0.0;
        SList[10] := 0.0;
        SList[16] := 0.0;
        SList[5] := 0.0;
        SList[11] := 0.25;
        SList[17] := -2.15;
        SList[21] := -1.5459500000000002;
        SList[22] := 0.0;
        SList[23] := ((fTelescopePos + 2.4289899999999998) + 2.4) - 0.25;
        SList[27] := 0.3362;
        SList[28] := 0.0 - (((fTelescopePos + 2.4289899999999998) + 2.4) - 0.25);
        SList[29] := 0.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        
        (* Explicitly pre-assign outputs *)
        (* '<S2>:1:53' thetaList    = zeros(5,1); *)
        (* '<S2>:1:54' thetaListDot = zeros(5,1); *)
        (* '<S2>:1:55' success      = false; *)
        (* or 0 if you prefer numeric *)
        (* '<S2>:1:58' T = [1 0 0 x; *)
        (* '<S2>:1:59'     0 1 0 y; *)
        (* '<S2>:1:60'     0 0 1 z; *)
        (* '<S2>:1:61'     0 0 0 1]; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        T[0] := 1.0;
        T[4] := 0.0;
        T[8] := 0.0;
        T[12] := fXRef;
        T[1] := 0.0;
        T[5] := 1.0;
        T[9] := 0.0;
        T[13] := fYRef;
        T[2] := 0.0;
        T[6] := 0.0;
        T[10] := 1.0;
        T[14] := fZRef;
        T[3] := 0.0;
        T[7] := 0.0;
        T[11] := 0.0;
        T[15] := 1.0;
        (* '<S2>:1:64' [thetaOut, successOut] = IKinSpace(SList, M, T, thetaList0, 0.00001, 0.0000001); *)
        (* *** CHAPTER 6: INVERSE KINEMATICS *** *)
        (* Takes Slist: The joint screw axes in the space frame when the manipulator *)
        (* is at the home position, in the format of a matrix with the *)
        (* screw axes as the columns, *)
        (* M: The home configuration of the end-effector, *)
        (* T: The desired end-effector configuration Tsd, *)
        (* thetalist0: An initial guess of joint angles that are close to  *)
        (* satisfying Tsd, *)
        (* eomg: A small positive tolerance on the end-effector orientation  *)
        (* error. The returned joint angles must give an end-effector  *)
        (* orientation error less than eomg, *)
        (* ev: A small positive tolerance on the end-effector linear position  *)
        (* error. The returned joint angles must give an end-effector  *)
        (* position error less than ev. *)
        (* Returns thetalist: Joint angles that achieve T within the specified  *)
        (* tolerances, *)
        (* success: A logical value where TRUE means that the function found *)
        (* a solution and FALSE means that it ran through the set  *)
        (* number of maximum iterations without finding a solution *)
        (* within the tolerances eomg and ev. *)
        (* Uses an iterative Newton-Raphson root-finding method. *)
        (* The maximum number of iterations before the algorithm is terminated has  *)
        (* been hardcoded in as a variable called maxiterations. It is set to 20 at  *)
        (* the start of the function, but can be changed if needed.   *)
        (* Example Inputs: *)
        
        (* clear; clc; *)
        (* Slist = [[0; 0;  1;  4; 0;    0], ... *)
        (* [0; 0;  0;  0; 1;    0], ... *)
        (* [0; 0; -1; -6; 0; -0.1]]; *)
        (* M = [[-1, 0, 0, 0]; [0, 1, 0, 6]; [0, 0, -1, 2]; [0, 0, 0, 1]]; *)
        (* T = [[0, 1, 0, -5]; [1, 0, 0, 4]; [0, 0, -1, 1.6858]; [0, 0, 0, 1]]; *)
        (* thetalist0 = [1.5; 2.5; 3]; *)
        (* eomg = 0.01; *)
        (* ev = 0.001; *)
        (* [thetalist, success] = IKinSpace(Slist, M, T, thetalist0, eomg, ev) *)
        
        (* Output: *)
        (* thetalist = *)
        (* 1.5707 *)
        (* 2.9997 *)
        (* 3.1415 *)
        (* success = *)
        (* 1 *)
        (* 'IKinSpace:48' thetalist = thetalist0; *)
        (* 'IKinSpace:49' i = 0; *)
        i := 0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'IKinSpace:50' maxiterations = 20; *)
        (* 'IKinSpace:51' Tsb = FKinSpace(M, Slist, thetalist); *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 15 DO 
            Tsb[i_0] := M[i_0];
        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* *** CHAPTER 4: FORWARD KINEMATICS *** *)
        (* Takes M: the home configuration (position and orientation) of the  *)
        (* end-effector, *)
        (* Slist: The joint screw axes in the space frame when the manipulator *)
        (* is at the home position, *)
        (* thetalist: A list of joint coordinates. *)
        (* Returns T in SE(3) representing the end-effector frame, when the joints  *)
        (* are at the specified coordinates (i.t.o Space Frame). *)
        (* Example Inputs: *)
        
        (* clear; clc; *)
        (* M = [[-1, 0, 0, 0]; [0, 1, 0, 6]; [0, 0, -1, 2]; [0, 0, 0, 1]]; *)
        (* Slist = [[0; 0;  1;  4; 0;    0], ... *)
        (* [0; 0;  0;  0; 1;    0], ... *)
        (* [0; 0; -1; -6; 0; -0.1]]; *)
        (* thetalist =[pi / 2; 3; pi]; *)
        (* T = FKinSpace(M, Slist, thetalist) *)
        
        (* Output: *)
        (* T = *)
        (* -0.0000    1.0000         0   -5.0000 *)
        (* 1.0000    0.0000         0    4.0000 *)
        (* 0         0   -1.0000    1.6858 *)
        (* 0         0         0    1.0000 *)
        (* 'FKinSpace:27' T = M; *)
        (* 'FKinSpace:28' for i = size(thetalist, 1): -1: 1 *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        se3mat[0] := 0.0;
        se3mat[5] := 0.0;
        se3mat[10] := 0.0;
        se3mat[3] := 0.0;
        se3mat[7] := 0.0;
        se3mat[11] := 0.0;
        se3mat[15] := 0.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR c_i := 0 TO 4 DO 
            (* 'FKinSpace:29' T = MatrixExp6(VecTose3(Slist(:, i) * thetalist(i))) * T; *)
            thetalist0_0 := thetalist0[4 - c_i];

            FOR i_0 := 0 TO 5 DO 
                V[i_0] := SList[((4 - c_i) * 6) + i_0] * thetalist0_0;
            END_FOR;

            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 6-vector (representing a spatial velocity). *)
            (* Returns the corresponding 4x4 se(3) matrix. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* V = [1; 2; 3; 4; 5; 6]; *)
            (* se3mat = VecTose3(V) *)
            
            (* Output: *)
            (* se3mat = *)
            (* 0    -3     2     4 *)
            (* 3     0    -1     5 *)
            (* -2     1     0     6 *)
            (* 0     0     0     0  *)
            (* 'VecTose3:18' se3mat = [VecToso3(V(1: 3)), V(4: 6); 0, 0, 0, 0]; *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 3-vector (angular velocity). *)
            (* Returns the skew symmetric matrix in so(3). *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* omg = [1; 2; 3]; *)
            (* so3mat = VecToso3(omg) *)
            
            (* Output: *)
            (* so3mat = *)
            (* 0    -3     2 *)
            (* 3     0    -1 *)
            (* -2     1     0 *)
            (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
            se3mat[4] :=  -V[2];
            se3mat[8] := V[1];
            se3mat[1] := V[2];
            se3mat[9] :=  -V[0];
            se3mat[2] :=  -V[1];
            se3mat[6] := V[0];
            se3mat[12] := V[3];
            se3mat[13] := V[4];
            se3mat[14] := V[5];
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a se(3) representation of exponential coordinates. *)
            (* Returns a T matrix in SE(3) that is achieved by traveling along/about the  *)
            (* screw axis S for a distance theta from an initial configuration T = I. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* se3mat = [ 0,      0,       0,      0; *)
            (* 0,      0, -1.5708, 2.3562; *)
            (* 0, 1.5708,       0, 2.3562; *)
            (* 0,      0,       0,      0] *)
            (* T = MatrixExp6(se3mat) *)
            
            (* Output: *)
            (* T = *)
            (* 1.0000         0         0         0 *)
            (* 0    0.0000   -1.0000   -0.0000 *)
            (* 0    1.0000    0.0000    3.0000 *)
            (* 0         0         0    1.0000  *)
            (* 'MatrixExp6:22' omgtheta = so3ToVec(se3mat(1: 3, 1: 3)); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
            (* Returns the corresponding 3-vector (angular velocity). *)
            (* Example Input:  *)
            
            (* clear; clc; *)
            (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
            (* omg = so3ToVec(so3mat)   *)
            
            (* Output: *)
            (* omg = *)
            (* 1 *)
            (* 2 *)
            (* 3 *)
            (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
            (* 'MatrixExp6:23' if NearZero(norm(omgtheta)) *)
            (* *** BASIC HELPER FUNCTIONS *** *)
            (* Takes a scalar. *)
            (* Checks if the scalar is small enough to be neglected. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* near = -1e-7; *)
            (* judge = NearZero(near) *)
            
            (* Output: *)
            (* judge = *)
            (* 1 *)
            (* 'NearZero:15' judge = norm(near) < 1e-6; *)
            se3mat_0[0] := V[0];
            se3mat_0[1] := V[1];
            se3mat_0[2] := V[2];
            d_theta := norm(x := se3mat_0);

            IF ABS(d_theta) < 1.0E-6 THEN 
                (* 'MatrixExp6:24' T = [eye(3), se3mat(1: 3, 4); 0, 0, 0, 1]; *)
                i0_eye();
                tmp_0 := i0_eye.I;

                FOR i_0 := 0 TO 2 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                    a[R_tmp] := tmp_0[3 * i_0];
                    a[R_tmp + 1] := tmp_0[(3 * i_0) + 1];
                    a[R_tmp + 2] := tmp_0[(3 * i_0) + 2];
                    a[i_0 + 12] := se3mat[i_0 + 12];
                END_FOR;

                a[3] := 0.0;
                a[7] := 0.0;
                a[11] := 0.0;
                a[15] := 1.0;
            ELSE 
                (* 'MatrixExp6:25' else *)
                (* 'MatrixExp6:26' [omghat, theta] = AxisAng3(omgtheta); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes A 3-vector of exponential coordinates for rotation. *)
                (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                (* angle theta. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* expc3 = [1; 2; 3]; *)
                (* [omghat, theta] = AxisAng3(expc3)   *)
                
                (* Output: *)
                (* omghat = *)
                (* 0.2673 *)
                (* 0.5345 *)
                (* 0.8018 *)
                (* theta = *)
                (* 3.7417 *)
                (* 'AxisAng3:20' theta = norm(expc3); *)
                (* 'AxisAng3:21' omghat = expc3 / theta; *)
                (* 'MatrixExp6:27' omgmat = se3mat(1: 3, 1: 3) / theta; *)

                FOR i_0 := 0 TO 2 DO 
                    omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                    omgmat[3 * i_0] := se3mat[omgmat_tmp] / d_theta;
                    omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / d_theta;
                    omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / d_theta;
                END_FOR;

                (* 'MatrixExp6:28' T = [MatrixExp3(se3mat(1: 3, 1: 3)), ... *)
                (* 'MatrixExp6:29'          (eye(3) * theta + (1 - cos(theta)) * omgmat ... *)
                (* 'MatrixExp6:30'           + (theta - sin(theta)) * omgmat * omgmat) ... *)
                (* 'MatrixExp6:31'             * se3mat(1: 3, 4) / theta; *)
                (* 'MatrixExp6:32'          0, 0, 0, 1]; *)
                thetalist0_0 := 1.0 - COS(d_theta);
                g_a := d_theta - SIN(d_theta);
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3x3 so(3) representation of exponential coordinates. *)
                (* Returns R in SO(3) that is achieved by rotating about omghat by theta  *)
                (* from an initial orientation R = I. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                (* R = MatrixExp3(so3mat)   *)
                
                (* Output: *)
                (* R = *)
                (* -0.6949    0.7135    0.0893 *)
                (* -0.1920   -0.3038    0.9332 *)
                (* 0.6930    0.6313    0.3481 *)
                (* 'MatrixExp3:18' omgtheta = so3ToVec(so3mat); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
                (* Returns the corresponding 3-vector (angular velocity). *)
                (* Example Input:  *)
                
                (* clear; clc; *)
                (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                (* omg = so3ToVec(so3mat)   *)
                
                (* Output: *)
                (* omg = *)
                (* 1 *)
                (* 2 *)
                (* 3 *)
                (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
                (* 'MatrixExp3:19' if NearZero(norm(omgtheta)) *)
                (* *** BASIC HELPER FUNCTIONS *** *)
                (* Takes a scalar. *)
                (* Checks if the scalar is small enough to be neglected. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* near = -1e-7; *)
                (* judge = NearZero(near) *)
                
                (* Output: *)
                (* judge = *)
                (* 1 *)
                (* 'NearZero:15' judge = norm(near) < 1e-6; *)
                se3mat_0[0] := V[0];
                se3mat_0[1] := V[1];
                se3mat_0[2] := V[2];
                g_theta := norm(x := se3mat_0);

                IF ABS(g_theta) < 1.0E-6 THEN 
                    (* 'MatrixExp3:20' R = eye(3); *)
                    i0_eye();
                    b_R := i0_eye.I;
                ELSE 
                    (* 'MatrixExp3:21' else *)
                    (* 'MatrixExp3:22' [omghat, theta] = AxisAng3(omgtheta); *)
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes A 3-vector of exponential coordinates for rotation. *)
                    (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                    (* angle theta. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* expc3 = [1; 2; 3]; *)
                    (* [omghat, theta] = AxisAng3(expc3)   *)
                    
                    (* Output: *)
                    (* omghat = *)
                    (* 0.2673 *)
                    (* 0.5345 *)
                    (* 0.8018 *)
                    (* theta = *)
                    (* 3.7417 *)
                    (* 'AxisAng3:20' theta = norm(expc3); *)
                    (* 'AxisAng3:21' omghat = expc3 / theta; *)
                    (* 'MatrixExp3:23' omgmat = so3mat / theta; *)

                    FOR i_0 := 0 TO 2 DO 
                        omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                        b_omgmat[3 * i_0] := se3mat[omgmat_tmp] / g_theta;
                        b_omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / g_theta;
                        b_omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / g_theta;
                    END_FOR;

                    (* 'MatrixExp3:24' R = eye(3) + sin(theta) * omgmat + (1 - cos(theta)) * omgmat * omgmat; *)
                    l_a := SIN(g_theta);
                    x_tmp := COS(g_theta);
                    i0_eye();
                    tmp_0 := i0_eye.I;

                    FOR i_0 := 0 TO 2 DO 

                        FOR omgmat_tmp := 0 TO 2 DO 
                            R_tmp := (3 * omgmat_tmp) + i_0;
                            b_R[R_tmp] := (((((1.0 - x_tmp) * b_omgmat[i_0 + 3]) * b_omgmat[(3 * omgmat_tmp) + 1]) + (((1.0 - x_tmp) * b_omgmat[i_0]) * b_omgmat[3 * omgmat_tmp])) + ((b_omgmat[i_0 + 6] * (1.0 - x_tmp)) * b_omgmat[(3 * omgmat_tmp) + 2])) + ((b_omgmat[R_tmp] * l_a) + tmp_0[R_tmp]);
                        END_FOR;

                    END_FOR;

                END_IF;


                FOR i_0 := 0 TO 2 DO 
                    x_tmp := 0.0;

                    FOR omgmat_tmp := 0 TO 2 DO 
                        R_tmp := (3 * omgmat_tmp) + i_0;
                        x_tmp := ((((((omgmat[i_0 + 3] * g_a) * omgmat[(3 * omgmat_tmp) + 1]) + ((g_a * omgmat[i_0]) * omgmat[3 * omgmat_tmp])) + ((omgmat[i_0 + 6] * g_a) * omgmat[(3 * omgmat_tmp) + 2])) + ((SINT_TO_LREAL(p_a[R_tmp]) * d_theta) + (omgmat[R_tmp] * thetalist0_0))) * se3mat[omgmat_tmp + 12]) + x_tmp;
                        a[omgmat_tmp + (i_0 * 4)] := b_R[(3 * i_0) + omgmat_tmp];
                    END_FOR;

                    a[i_0 + 12] := x_tmp / d_theta;
                END_FOR;

                a[3] := 0.0;
                a[7] := 0.0;
                a[11] := 0.0;
                a[15] := 1.0;
            END_IF;


            FOR i_0 := 0 TO 3 DO 
                thetalist0_0 := a[i_0 + 4];
                g_a := a[i_0];
                l_a := a[i_0 + 8];
                x_tmp := a[i_0 + 12];

                FOR omgmat_tmp := 0 TO 3 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                    a_0[i_0 + R_tmp] := (((Tsb[R_tmp + 1] * thetalist0_0) + (Tsb[R_tmp] * g_a)) + (Tsb[R_tmp + 2] * l_a)) + (Tsb[R_tmp + 3] * x_tmp);
                END_FOR;

            END_FOR;


            FOR i_0 := 0 TO 15 DO 
                Tsb[i_0] := a_0[i_0];
            END_FOR;

        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'IKinSpace:52' Vs = Adjoint(Tsb) * se3ToVec(MatrixLog6(TransInv(Tsb) * T)); *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes a transformation matrix T. *)
        (* Returns its inverse.  *)
        (* Uses the structure of transformation matrices to avoid taking a matrix *)
        (* inverse, for efficiency. *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
        (* invT = TransInv(T) *)
        
        (* Ouput: *)
        (* invT = *)
        (* 1     0     0     0 *)
        (* 0     0     1    -3 *)
        (* 0    -1     0     0 *)
        (* 0     0     0     1 *)
        (* 'TransInv:20' [R, p] = TransToRp(T); *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes the transformation matrix T in SE(3)  *)
        (* Returns R: the corresponding rotation matrix *)
        (* p: the corresponding position vector . *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
        (* [R, p] = TransToRp(T) *)
        
        (* Output: *)
        (* R = *)
        (* 1     0     0 *)
        (* 0     0    -1 *)
        (* 0     1     0 *)
        (* p = *)
        (* 0 *)
        (* 0 *)
        (* 3 *)
        (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
        (* 'TransToRp:23' p = T(1: 3, 4); *)
        (* 'TransInv:21' invT = [transpose(R), -transpose(R) * p; 0, 0, 0, 1]; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 2 DO 
            omgmat[3 * i_0] := Tsb[i_0];
            omgmat[(3 * i_0) + 1] := Tsb[i_0 + 4];
            omgmat[(3 * i_0) + 2] := Tsb[i_0 + 8];
        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 8 DO 
            b_R[i_0] :=  -omgmat[i_0];
        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        thetalist0_0 := Tsb[13];
        g_a := Tsb[12];
        l_a := Tsb[14];

        FOR i_0 := 0 TO 2 DO 
            omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
            se3mat[omgmat_tmp] := omgmat[3 * i_0];
            se3mat[omgmat_tmp + 1] := omgmat[(3 * i_0) + 1];
            se3mat[omgmat_tmp + 2] := omgmat[(3 * i_0) + 2];
            se3mat[i_0 + 12] := ((b_R[i_0 + 3] * thetalist0_0) + (b_R[i_0] * g_a)) + (b_R[i_0 + 6] * l_a);
        END_FOR;

        se3mat[3] := 0.0;
        se3mat[7] := 0.0;
        se3mat[11] := 0.0;
        se3mat[15] := 1.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 3 DO 
            R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
            thetalist0_0 := T[R_tmp + 1];
            g_a := T[R_tmp];
            l_a := T[R_tmp + 2];
            x_tmp := T[R_tmp + 3];

            FOR omgmat_tmp := 0 TO 3 DO 
                a_0[omgmat_tmp + R_tmp] := (((thetalist0_0 * se3mat[omgmat_tmp + 4]) + (g_a * se3mat[omgmat_tmp])) + (l_a * se3mat[omgmat_tmp + 8])) + (x_tmp * se3mat[omgmat_tmp + 12]);
            END_FOR;

        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes a transformation matrix T in SE(3). *)
        (* Returns the corresponding se(3) representation of exponential  *)
        (* coordinates. *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
        (* expmat = MatrixLog6(T) *)
        
        (* Output: *)
        (* expc6 = *)
        (* 0         0         0         0 *)
        (* 0         0   -1.5708    2.3562 *)
        (* 0    1.5708         0    2.3562 *)
        (* 0         0         0         0 *)
        (* 'MatrixLog6:19' [R, p] = TransToRp(T); *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes the transformation matrix T in SE(3)  *)
        (* Returns R: the corresponding rotation matrix *)
        (* p: the corresponding position vector . *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
        (* [R, p] = TransToRp(T) *)
        
        (* Output: *)
        (* R = *)
        (* 1     0     0 *)
        (* 0     0    -1 *)
        (* 0     1     0 *)
        (* p = *)
        (* 0 *)
        (* 0 *)
        (* 3 *)
        (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
        (* 'TransToRp:23' p = T(1: 3, 4); *)
        (* 'MatrixLog6:20' omgmat = MatrixLog3(R); *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 2 DO 
            R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
            b_R[3 * i_0] := a_0[R_tmp];
            b_R[(3 * i_0) + 1] := a_0[R_tmp + 1];
            b_R[(3 * i_0) + 2] := a_0[R_tmp + 2];
        END_FOR;

        i0_MatrixLog3(b_R := b_R);
        omgmat := i0_MatrixLog3.so3mat;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'MatrixLog6:21' if isequal(omgmat, zeros(3)) *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 8 DO 
            tmp_0[i_0] := 0.0;
        END_FOR;


        IF isequal(varargin_1 := omgmat, varargin_2 := tmp_0) THEN 
            (* 'MatrixLog6:22' expmat = [zeros(3), T(1: 3, 4); 0, 0, 0, 0]; *)

            FOR i_0 := 0 TO 2 DO 
                omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                se3mat[omgmat_tmp] := 0.0;
                se3mat[omgmat_tmp + 1] := 0.0;
                se3mat[omgmat_tmp + 2] := 0.0;
                se3mat[i_0 + 12] := a_0[i_0 + 12];
            END_FOR;

            se3mat[3] := 0.0;
            se3mat[7] := 0.0;
            se3mat[11] := 0.0;
            se3mat[15] := 0.0;
        ELSE 
            (* 'MatrixLog6:23' else *)
            (* 'MatrixLog6:24' theta = acos((trace(R) - 1) / 2); *)
            theta := ACOS((((a_0[0] + a_0[5]) + a_0[10]) - 1.0) / 2.0);
            (* 'MatrixLog6:25' expmat = [omgmat, (eye(3) - omgmat / 2 ... *)
            (* 'MatrixLog6:26'                       + (1 / theta - cot(theta / 2) / 2) ... *)
            (* 'MatrixLog6:27'                         * omgmat * omgmat / theta) * p; *)
            (* 'MatrixLog6:28'               0, 0, 0, 0]; *)
            thetalist0_0 := (1.0 / theta) - ((1.0 / TAN(theta / 2.0)) / 2.0);
            i0_eye();
            tmp_0 := i0_eye.I;

            FOR i_0 := 0 TO 2 DO 
                x_tmp := 0.0;

                FOR omgmat_tmp := 0 TO 2 DO 
                    R_tmp := (3 * omgmat_tmp) + i_0;
                    x_tmp := (((((((omgmat[i_0 + 3] * thetalist0_0) * omgmat[(3 * omgmat_tmp) + 1]) + ((thetalist0_0 * omgmat[i_0]) * omgmat[3 * omgmat_tmp])) + ((omgmat[i_0 + 6] * thetalist0_0) * omgmat[(3 * omgmat_tmp) + 2])) / theta) + (tmp_0[R_tmp] - (omgmat[R_tmp] / 2.0))) * a_0[omgmat_tmp + 12]) + x_tmp;
                    se3mat[omgmat_tmp + (i_0 * 4)] := omgmat[(3 * i_0) + omgmat_tmp];
                END_FOR;

                se3mat[i_0 + 12] := x_tmp;
            END_FOR;

            se3mat[3] := 0.0;
            se3mat[7] := 0.0;
            se3mat[11] := 0.0;
            se3mat[15] := 0.0;
        END_IF;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes T a transformation matrix SE3.  *)
        (* Returns the corresponding 6x6 adjoint representation [AdT]. *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
        (* AdT = Adjoint(T) *)
        
        (* Output: *)
        (* AdT = *)
        (* 1     0     0     0     0     0 *)
        (* 0     0    -1     0     0     0 *)
        (* 0     1     0     0     0     0 *)
        (* 0     0     3     1     0     0 *)
        (* 3     0     0     0     0    -1 *)
        (* 0     0     0     0     1     0 *)
        (* 'Adjoint:20' [R, p] = TransToRp(T); *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes the transformation matrix T in SE(3)  *)
        (* Returns R: the corresponding rotation matrix *)
        (* p: the corresponding position vector . *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
        (* [R, p] = TransToRp(T) *)
        
        (* Output: *)
        (* R = *)
        (* 1     0     0 *)
        (* 0     0    -1 *)
        (* 0     1     0 *)
        (* p = *)
        (* 0 *)
        (* 0 *)
        (* 3 *)
        (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
        (* 'TransToRp:23' p = T(1: 3, 4); *)
        (* 'Adjoint:21' AdT = [R, zeros(3); VecToso3(p) * R, R]; *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes a 3-vector (angular velocity). *)
        (* Returns the skew symmetric matrix in so(3). *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* omg = [1; 2; 3]; *)
        (* so3mat = VecToso3(omg) *)
        
        (* Output: *)
        (* so3mat = *)
        (* 0    -3     2 *)
        (* 3     0    -1 *)
        (* -2     1     0 *)
        (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
        (* Takes se3mat a 4x4 se(3) matrix *)
        (* Returns the corresponding 6-vector (representing spatial velocity). *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* se3mat = [[0, -3, 2, 4]; [3, 0, -1, 5]; [-2, 1, 0, 6]; [0, 0, 0, 0]]; *)
        (* V = se3ToVec(se3mat) *)
        
        (* Output: *)
        (* V = *)
        (* 1 *)
        (* 2 *)
        (* 3 *)
        (* 4 *)
        (* 5 *)
        (* 6 *)
        (* 'se3ToVec:20' V = [se3mat(3, 2); se3mat(1, 3); se3mat(2, 1); se3mat(1: 3, 4)]; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        tmp_0[0] := 0.0;
        tmp_0[3] :=  -Tsb[14];
        tmp_0[6] := Tsb[13];
        tmp_0[1] := Tsb[14];
        tmp_0[4] := 0.0;
        tmp_0[7] :=  -Tsb[12];
        tmp_0[2] :=  -Tsb[13];
        tmp_0[5] := Tsb[12];
        tmp_0[8] := 0.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 2 DO 
            x_tmp := tmp_0[i_0 + 3];
            thetalist0_0 := tmp_0[i_0];
            g_a := tmp_0[i_0 + 6];

            FOR omgmat_tmp := 0 TO 2 DO 
                R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                tmp[i_0 + (3 * omgmat_tmp)] := ((Tsb[R_tmp + 1] * x_tmp) + (Tsb[R_tmp] * thetalist0_0)) + (Tsb[R_tmp + 2] * g_a);
                Tsb_0[omgmat_tmp + (6 * i_0)] := Tsb[(i_0 * 4) + omgmat_tmp];
                Tsb_0[omgmat_tmp + (6 * (i_0 + 3))] := 0.0;
            END_FOR;

        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        V[0] := se3mat[6];
        V[1] := se3mat[8];
        V[2] := se3mat[1];

        FOR i_0 := 0 TO 2 DO 
            Tsb_0[(6 * i_0) + 3] := tmp[3 * i_0];
            omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
            R_tmp := 6 * (i_0 + 3);
            Tsb_0[R_tmp + 3] := Tsb[omgmat_tmp];
            Tsb_0[(6 * i_0) + 4] := tmp[(3 * i_0) + 1];
            Tsb_0[R_tmp + 4] := Tsb[omgmat_tmp + 1];
            Tsb_0[(6 * i_0) + 5] := tmp[(3 * i_0) + 2];
            Tsb_0[R_tmp + 5] := Tsb[omgmat_tmp + 2];
            V[i_0 + 3] := se3mat[i_0 + 12];
        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 5 DO 
            thetalist0_0 := 0.0;

            FOR omgmat_tmp := 0 TO 5 DO 
                thetalist0_0 := (Tsb_0[(6 * omgmat_tmp) + i_0] * V[omgmat_tmp]) + thetalist0_0;
            END_FOR;

            Vs[i_0] := thetalist0_0;
        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'IKinSpace:53' err = norm(Vs(1: 3)) > eomg || norm(Vs(4: 6)) > ev; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        se3mat_0[0] := Vs[0];
        se3mat_0[1] := Vs[1];
        se3mat_0[2] := Vs[2];

        IF norm(x := se3mat_0) > 1.0E-5 THEN 
            err := TRUE;
        ELSE 
            se3mat_0[0] := Vs[3];
            se3mat_0[1] := Vs[4];
            se3mat_0[2] := Vs[5];

            IF norm(x := se3mat_0) > 1.0E-7 THEN 
                err := TRUE;
            ELSE 
                err := FALSE;
            END_IF;

        END_IF;

        (* 'IKinSpace:54' while err && i < maxiterations *)

        IF err THEN 
            tmp_3[0] := 0.0;
            tmp_3[4] := 0.0;
            tmp_3[8] := 0.0;
            tmp_4[0] := 0.0;
            tmp_4[4] := 0.0;
            tmp_4[8] := 0.0;

            FOR i_0 := 0 TO 8 DO 
                tmp_2[i_0] := 0.0;
            END_FOR;

        END_IF;

        WHILE err AND (i < 20) DO
            (* 'IKinSpace:55' thetalist = thetalist + pinv(JacobianSpace(Slist, thetalist)) * Vs; *)
            (* *** CHAPTER 5: VELOCITY KINEMATICS AND STATICS *** *)
            (* Takes Slist: The joint screw axes in the space frame when the manipulator *)
            (* is at the home position, in the format of a matrix with the *)
            (* screw axes as the columns, *)
            (* thetalist: A list of joint coordinates.  *)
            (* Returns the corresponding space Jacobian (6xn real numbers). *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* Slist = [[0; 0; 1;   0; 0.2; 0.2], ... *)
            (* [1; 0; 0;   2;   0;   3], ... *)
            (* [0; 1; 0;   0;   2;   1], ... *)
            (* [1; 0; 0; 0.2; 0.3; 0.4]]; *)
            (* thetalist = [0.2; 1.1; 0.1; 1.2]; *)
            (* Js = JacobianSpace(Slist, thetalist) *)
            
            (* Output: *)
            (* Js = *)
            (* 0    0.9801   -0.0901    0.9575 *)
            (* 0    0.1987    0.4446    0.2849 *)
            (* 1.0000         0    0.8912   -0.0453 *)
            (* 0    1.9522   -2.2164   -0.5116 *)
            (* 0.2000    0.4365   -2.4371    2.7754 *)
            (* 0.2000    2.9603    3.2357    2.2251 *)
            (* 'JacobianSpace:27' Js = Slist; *)

            FOR i_0 := 0 TO 29 DO 
                Js[i_0] := SList[i_0];
            END_FOR;

            (* 'JacobianSpace:28' T = eye(4); *)

            FOR i_0 := 0 TO 15 DO 
                a_0[i_0] := 0.0;
            END_FOR;

            a_0[0] := 1.0;
            a_0[5] := 1.0;
            a_0[10] := 1.0;
            a_0[15] := 1.0;
            (* 'JacobianSpace:29' for i = 2: length(thetalist) *)
            se3mat[0] := 0.0;
            se3mat[5] := 0.0;
            se3mat[10] := 0.0;
            se3mat[3] := 0.0;
            se3mat[7] := 0.0;
            se3mat[11] := 0.0;
            se3mat[15] := 0.0;

            FOR d_i := 0 TO 3 DO 
                (* 'JacobianSpace:30' T = T * MatrixExp6(VecTose3(Slist(:, i - 1) * thetalist(i - 1))); *)
                thetalist0_0 := thetalist0[d_i];

                FOR i_0 := 0 TO 5 DO 
                    V[i_0] := SList[(6 * d_i) + i_0] * thetalist0_0;
                END_FOR;

                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 6-vector (representing a spatial velocity). *)
                (* Returns the corresponding 4x4 se(3) matrix. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* V = [1; 2; 3; 4; 5; 6]; *)
                (* se3mat = VecTose3(V) *)
                
                (* Output: *)
                (* se3mat = *)
                (* 0    -3     2     4 *)
                (* 3     0    -1     5 *)
                (* -2     1     0     6 *)
                (* 0     0     0     0  *)
                (* 'VecTose3:18' se3mat = [VecToso3(V(1: 3)), V(4: 6); 0, 0, 0, 0]; *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3-vector (angular velocity). *)
                (* Returns the skew symmetric matrix in so(3). *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* omg = [1; 2; 3]; *)
                (* so3mat = VecToso3(omg) *)
                
                (* Output: *)
                (* so3mat = *)
                (* 0    -3     2 *)
                (* 3     0    -1 *)
                (* -2     1     0 *)
                (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
                se3mat[4] :=  -V[2];
                se3mat[8] := V[1];
                se3mat[1] := V[2];
                se3mat[9] :=  -V[0];
                se3mat[2] :=  -V[1];
                se3mat[6] := V[0];
                se3mat[12] := V[3];
                se3mat[13] := V[4];
                se3mat[14] := V[5];
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a se(3) representation of exponential coordinates. *)
                (* Returns a T matrix in SE(3) that is achieved by traveling along/about the  *)
                (* screw axis S for a distance theta from an initial configuration T = I. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* se3mat = [ 0,      0,       0,      0; *)
                (* 0,      0, -1.5708, 2.3562; *)
                (* 0, 1.5708,       0, 2.3562; *)
                (* 0,      0,       0,      0] *)
                (* T = MatrixExp6(se3mat) *)
                
                (* Output: *)
                (* T = *)
                (* 1.0000         0         0         0 *)
                (* 0    0.0000   -1.0000   -0.0000 *)
                (* 0    1.0000    0.0000    3.0000 *)
                (* 0         0         0    1.0000  *)
                (* 'MatrixExp6:22' omgtheta = so3ToVec(se3mat(1: 3, 1: 3)); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
                (* Returns the corresponding 3-vector (angular velocity). *)
                (* Example Input:  *)
                
                (* clear; clc; *)
                (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                (* omg = so3ToVec(so3mat)   *)
                
                (* Output: *)
                (* omg = *)
                (* 1 *)
                (* 2 *)
                (* 3 *)
                (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
                qs4[0] := V[0];
                qs4[1] := V[1];
                qs4[2] := V[2];
                (* 'MatrixExp6:23' if NearZero(norm(omgtheta)) *)
                (* *** BASIC HELPER FUNCTIONS *** *)
                (* Takes a scalar. *)
                (* Checks if the scalar is small enough to be neglected. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* near = -1e-7; *)
                (* judge = NearZero(near) *)
                
                (* Output: *)
                (* judge = *)
                (* 1 *)
                (* 'NearZero:15' judge = norm(near) < 1e-6; *)
                e_theta := norm(x := qs4);

                IF ABS(e_theta) < 1.0E-6 THEN 
                    (* 'MatrixExp6:24' T = [eye(3), se3mat(1: 3, 4); 0, 0, 0, 1]; *)
                    i0_eye();
                    tmp_0 := i0_eye.I;

                    FOR i_0 := 0 TO 2 DO 
                        R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                        a[R_tmp] := tmp_0[3 * i_0];
                        a[R_tmp + 1] := tmp_0[(3 * i_0) + 1];
                        a[R_tmp + 2] := tmp_0[(3 * i_0) + 2];
                        a[i_0 + 12] := se3mat[i_0 + 12];
                    END_FOR;

                    a[3] := 0.0;
                    a[7] := 0.0;
                    a[11] := 0.0;
                    a[15] := 1.0;
                ELSE 
                    (* 'MatrixExp6:25' else *)
                    (* 'MatrixExp6:26' [omghat, theta] = AxisAng3(omgtheta); *)
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes A 3-vector of exponential coordinates for rotation. *)
                    (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                    (* angle theta. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* expc3 = [1; 2; 3]; *)
                    (* [omghat, theta] = AxisAng3(expc3)   *)
                    
                    (* Output: *)
                    (* omghat = *)
                    (* 0.2673 *)
                    (* 0.5345 *)
                    (* 0.8018 *)
                    (* theta = *)
                    (* 3.7417 *)
                    (* 'AxisAng3:20' theta = norm(expc3); *)
                    (* 'AxisAng3:21' omghat = expc3 / theta; *)
                    (* 'MatrixExp6:27' omgmat = se3mat(1: 3, 1: 3) / theta; *)

                    FOR i_0 := 0 TO 2 DO 
                        omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                        omgmat[3 * i_0] := se3mat[omgmat_tmp] / e_theta;
                        omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / e_theta;
                        omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / e_theta;
                    END_FOR;

                    (* 'MatrixExp6:28' T = [MatrixExp3(se3mat(1: 3, 1: 3)), ... *)
                    (* 'MatrixExp6:29'          (eye(3) * theta + (1 - cos(theta)) * omgmat ... *)
                    (* 'MatrixExp6:30'           + (theta - sin(theta)) * omgmat * omgmat) ... *)
                    (* 'MatrixExp6:31'             * se3mat(1: 3, 4) / theta; *)
                    (* 'MatrixExp6:32'          0, 0, 0, 1]; *)
                    thetalist0_0 := 1.0 - COS(e_theta);
                    g_a := e_theta - SIN(e_theta);
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes a 3x3 so(3) representation of exponential coordinates. *)
                    (* Returns R in SO(3) that is achieved by rotating about omghat by theta  *)
                    (* from an initial orientation R = I. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                    (* R = MatrixExp3(so3mat)   *)
                    
                    (* Output: *)
                    (* R = *)
                    (* -0.6949    0.7135    0.0893 *)
                    (* -0.1920   -0.3038    0.9332 *)
                    (* 0.6930    0.6313    0.3481 *)
                    (* 'MatrixExp3:18' omgtheta = so3ToVec(so3mat); *)
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
                    (* Returns the corresponding 3-vector (angular velocity). *)
                    (* Example Input:  *)
                    
                    (* clear; clc; *)
                    (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                    (* omg = so3ToVec(so3mat)   *)
                    
                    (* Output: *)
                    (* omg = *)
                    (* 1 *)
                    (* 2 *)
                    (* 3 *)
                    (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
                    qs4[0] := V[0];
                    qs4[1] := V[1];
                    qs4[2] := V[2];
                    (* 'MatrixExp3:19' if NearZero(norm(omgtheta)) *)
                    (* *** BASIC HELPER FUNCTIONS *** *)
                    (* Takes a scalar. *)
                    (* Checks if the scalar is small enough to be neglected. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* near = -1e-7; *)
                    (* judge = NearZero(near) *)
                    
                    (* Output: *)
                    (* judge = *)
                    (* 1 *)
                    (* 'NearZero:15' judge = norm(near) < 1e-6; *)
                    h_theta := norm(x := qs4);

                    IF ABS(h_theta) < 1.0E-6 THEN 
                        (* 'MatrixExp3:20' R = eye(3); *)
                        i0_eye();
                        b_R := i0_eye.I;
                    ELSE 
                        (* 'MatrixExp3:21' else *)
                        (* 'MatrixExp3:22' [omghat, theta] = AxisAng3(omgtheta); *)
                        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                        (* Takes A 3-vector of exponential coordinates for rotation. *)
                        (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                        (* angle theta. *)
                        (* Example Input: *)
                        
                        (* clear; clc; *)
                        (* expc3 = [1; 2; 3]; *)
                        (* [omghat, theta] = AxisAng3(expc3)   *)
                        
                        (* Output: *)
                        (* omghat = *)
                        (* 0.2673 *)
                        (* 0.5345 *)
                        (* 0.8018 *)
                        (* theta = *)
                        (* 3.7417 *)
                        (* 'AxisAng3:20' theta = norm(expc3); *)
                        (* 'AxisAng3:21' omghat = expc3 / theta; *)
                        (* 'MatrixExp3:23' omgmat = so3mat / theta; *)

                        FOR i_0 := 0 TO 2 DO 
                            omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                            b_omgmat[3 * i_0] := se3mat[omgmat_tmp] / h_theta;
                            b_omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / h_theta;
                            b_omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / h_theta;
                        END_FOR;

                        (* 'MatrixExp3:24' R = eye(3) + sin(theta) * omgmat + (1 - cos(theta)) * omgmat * omgmat; *)
                        l_a := SIN(h_theta);
                        x_tmp := COS(h_theta);
                        i0_eye();
                        tmp_0 := i0_eye.I;

                        FOR i_0 := 0 TO 2 DO 

                            FOR omgmat_tmp := 0 TO 2 DO 
                                R_tmp := (3 * omgmat_tmp) + i_0;
                                b_R[R_tmp] := (((((1.0 - x_tmp) * b_omgmat[i_0 + 3]) * b_omgmat[(3 * omgmat_tmp) + 1]) + (((1.0 - x_tmp) * b_omgmat[i_0]) * b_omgmat[3 * omgmat_tmp])) + ((b_omgmat[i_0 + 6] * (1.0 - x_tmp)) * b_omgmat[(3 * omgmat_tmp) + 2])) + ((b_omgmat[R_tmp] * l_a) + tmp_0[R_tmp]);
                            END_FOR;

                        END_FOR;

                    END_IF;


                    FOR i_0 := 0 TO 2 DO 
                        x_tmp := 0.0;

                        FOR omgmat_tmp := 0 TO 2 DO 
                            R_tmp := (3 * omgmat_tmp) + i_0;
                            x_tmp := ((((((omgmat[i_0 + 3] * g_a) * omgmat[(3 * omgmat_tmp) + 1]) + ((g_a * omgmat[i_0]) * omgmat[3 * omgmat_tmp])) + ((omgmat[i_0 + 6] * g_a) * omgmat[(3 * omgmat_tmp) + 2])) + ((SINT_TO_LREAL(p_a[R_tmp]) * e_theta) + (omgmat[R_tmp] * thetalist0_0))) * se3mat[omgmat_tmp + 12]) + x_tmp;
                            a[omgmat_tmp + (i_0 * 4)] := b_R[(3 * i_0) + omgmat_tmp];
                        END_FOR;

                        a[i_0 + 12] := x_tmp / e_theta;
                    END_FOR;

                    a[3] := 0.0;
                    a[7] := 0.0;
                    a[11] := 0.0;
                    a[15] := 1.0;
                END_IF;


                FOR i_0 := 0 TO 3 DO 
                    thetalist0_0 := a_0[i_0 + 4];
                    g_a := a_0[i_0];
                    l_a := a_0[i_0 + 8];
                    x_tmp := a_0[i_0 + 12];

                    FOR omgmat_tmp := 0 TO 3 DO 
                        R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                        b_T[i_0 + R_tmp] := (((a[R_tmp + 1] * thetalist0_0) + (a[R_tmp] * g_a)) + (a[R_tmp + 2] * l_a)) + (a[R_tmp + 3] * x_tmp);
                    END_FOR;

                END_FOR;


                FOR i_0 := 0 TO 15 DO 
                    a_0[i_0] := b_T[i_0];
                END_FOR;

                (* 'JacobianSpace:31' Js(:, i) = Adjoint(T) * Slist(:, i); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes T a transformation matrix SE3.  *)
                (* Returns the corresponding 6x6 adjoint representation [AdT]. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
                (* AdT = Adjoint(T) *)
                
                (* Output: *)
                (* AdT = *)
                (* 1     0     0     0     0     0 *)
                (* 0     0    -1     0     0     0 *)
                (* 0     1     0     0     0     0 *)
                (* 0     0     3     1     0     0 *)
                (* 3     0     0     0     0    -1 *)
                (* 0     0     0     0     1     0 *)
                (* 'Adjoint:20' [R, p] = TransToRp(T); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes the transformation matrix T in SE(3)  *)
                (* Returns R: the corresponding rotation matrix *)
                (* p: the corresponding position vector . *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
                (* [R, p] = TransToRp(T) *)
                
                (* Output: *)
                (* R = *)
                (* 1     0     0 *)
                (* 0     0    -1 *)
                (* 0     1     0 *)
                (* p = *)
                (* 0 *)
                (* 0 *)
                (* 3 *)
                (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
                (* 'TransToRp:23' p = T(1: 3, 4); *)
                (* 'Adjoint:21' AdT = [R, zeros(3); VecToso3(p) * R, R]; *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3-vector (angular velocity). *)
                (* Returns the skew symmetric matrix in so(3). *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* omg = [1; 2; 3]; *)
                (* so3mat = VecToso3(omg) *)
                
                (* Output: *)
                (* so3mat = *)
                (* 0    -3     2 *)
                (* 3     0    -1 *)
                (* -2     1     0 *)
                (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
                tmp_3[3] :=  -a_0[14];
                tmp_3[6] := a_0[13];
                tmp_3[1] := a_0[14];
                tmp_3[7] :=  -a_0[12];
                tmp_3[2] :=  -a_0[13];
                tmp_3[5] := a_0[12];

                FOR i_0 := 0 TO 2 DO 
                    x_tmp := tmp_3[i_0 + 3];
                    thetalist0_0 := tmp_3[i_0];
                    g_a := tmp_3[i_0 + 6];

                    FOR omgmat_tmp := 0 TO 2 DO 
                        R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                        tmp_0[i_0 + (3 * omgmat_tmp)] := ((a_0[R_tmp + 1] * x_tmp) + (a_0[R_tmp] * thetalist0_0)) + (a_0[R_tmp + 2] * g_a);
                        Tsb_0[omgmat_tmp + (6 * i_0)] := a_0[(i_0 * 4) + omgmat_tmp];
                        Tsb_0[omgmat_tmp + (6 * (i_0 + 3))] := 0.0;
                    END_FOR;

                END_FOR;


                FOR i_0 := 0 TO 2 DO 
                    Tsb_0[(6 * i_0) + 3] := tmp_0[3 * i_0];
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                    omgmat_tmp := 6 * (i_0 + 3);
                    Tsb_0[omgmat_tmp + 3] := a_0[R_tmp];
                    Tsb_0[(6 * i_0) + 4] := tmp_0[(3 * i_0) + 1];
                    Tsb_0[omgmat_tmp + 4] := a_0[R_tmp + 1];
                    Tsb_0[(6 * i_0) + 5] := tmp_0[(3 * i_0) + 2];
                    Tsb_0[omgmat_tmp + 5] := a_0[R_tmp + 2];
                END_FOR;


                FOR i_0 := 0 TO 5 DO 
                    thetalist0_0 := 0.0;

                    FOR omgmat_tmp := 0 TO 5 DO 
                        thetalist0_0 := (SList[((d_i + 1) * 6) + omgmat_tmp] * Tsb_0[(6 * omgmat_tmp) + i_0]) + thetalist0_0;
                    END_FOR;

                    Js[i_0 + (6 * (d_i + 1))] := thetalist0_0;
                END_FOR;

            END_FOR;

            i0_pinv(A := Js);
            tmp_1 := i0_pinv.X;

            FOR i_0 := 0 TO 4 DO 
                x_tmp := 0.0;

                FOR omgmat_tmp := 0 TO 5 DO 
                    x_tmp := (tmp_1[(5 * omgmat_tmp) + i_0] * Vs[omgmat_tmp]) + x_tmp;
                END_FOR;

                thetalist0[i_0] := thetalist0[i_0] + x_tmp;
            END_FOR;

            (* 'IKinSpace:56' i = i + 1; *)
            i := i + 1;
            (* 'IKinSpace:57' Tsb = FKinSpace(M, Slist, thetalist); *)

            FOR i_0 := 0 TO 15 DO 
                Tsb[i_0] := M[i_0];
            END_FOR;

            (* *** CHAPTER 4: FORWARD KINEMATICS *** *)
            (* Takes M: the home configuration (position and orientation) of the  *)
            (* end-effector, *)
            (* Slist: The joint screw axes in the space frame when the manipulator *)
            (* is at the home position, *)
            (* thetalist: A list of joint coordinates. *)
            (* Returns T in SE(3) representing the end-effector frame, when the joints  *)
            (* are at the specified coordinates (i.t.o Space Frame). *)
            (* Example Inputs: *)
            
            (* clear; clc; *)
            (* M = [[-1, 0, 0, 0]; [0, 1, 0, 6]; [0, 0, -1, 2]; [0, 0, 0, 1]]; *)
            (* Slist = [[0; 0;  1;  4; 0;    0], ... *)
            (* [0; 0;  0;  0; 1;    0], ... *)
            (* [0; 0; -1; -6; 0; -0.1]]; *)
            (* thetalist =[pi / 2; 3; pi]; *)
            (* T = FKinSpace(M, Slist, thetalist) *)
            
            (* Output: *)
            (* T = *)
            (* -0.0000    1.0000         0   -5.0000 *)
            (* 1.0000    0.0000         0    4.0000 *)
            (* 0         0   -1.0000    1.6858 *)
            (* 0         0         0    1.0000 *)
            (* 'FKinSpace:27' T = M; *)
            (* 'FKinSpace:28' for i = size(thetalist, 1): -1: 1 *)
            se3mat[0] := 0.0;
            se3mat[5] := 0.0;
            se3mat[10] := 0.0;
            se3mat[3] := 0.0;
            se3mat[7] := 0.0;
            se3mat[11] := 0.0;
            se3mat[15] := 0.0;

            FOR e_i := 0 TO 4 DO 
                (* 'FKinSpace:29' T = MatrixExp6(VecTose3(Slist(:, i) * thetalist(i))) * T; *)
                thetalist0_0 := thetalist0[4 - e_i];

                FOR i_0 := 0 TO 5 DO 
                    V[i_0] := SList[((4 - e_i) * 6) + i_0] * thetalist0_0;
                END_FOR;

                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 6-vector (representing a spatial velocity). *)
                (* Returns the corresponding 4x4 se(3) matrix. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* V = [1; 2; 3; 4; 5; 6]; *)
                (* se3mat = VecTose3(V) *)
                
                (* Output: *)
                (* se3mat = *)
                (* 0    -3     2     4 *)
                (* 3     0    -1     5 *)
                (* -2     1     0     6 *)
                (* 0     0     0     0  *)
                (* 'VecTose3:18' se3mat = [VecToso3(V(1: 3)), V(4: 6); 0, 0, 0, 0]; *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3-vector (angular velocity). *)
                (* Returns the skew symmetric matrix in so(3). *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* omg = [1; 2; 3]; *)
                (* so3mat = VecToso3(omg) *)
                
                (* Output: *)
                (* so3mat = *)
                (* 0    -3     2 *)
                (* 3     0    -1 *)
                (* -2     1     0 *)
                (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
                se3mat[4] :=  -V[2];
                se3mat[8] := V[1];
                se3mat[1] := V[2];
                se3mat[9] :=  -V[0];
                se3mat[2] :=  -V[1];
                se3mat[6] := V[0];
                se3mat[12] := V[3];
                se3mat[13] := V[4];
                se3mat[14] := V[5];
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a se(3) representation of exponential coordinates. *)
                (* Returns a T matrix in SE(3) that is achieved by traveling along/about the  *)
                (* screw axis S for a distance theta from an initial configuration T = I. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* se3mat = [ 0,      0,       0,      0; *)
                (* 0,      0, -1.5708, 2.3562; *)
                (* 0, 1.5708,       0, 2.3562; *)
                (* 0,      0,       0,      0] *)
                (* T = MatrixExp6(se3mat) *)
                
                (* Output: *)
                (* T = *)
                (* 1.0000         0         0         0 *)
                (* 0    0.0000   -1.0000   -0.0000 *)
                (* 0    1.0000    0.0000    3.0000 *)
                (* 0         0         0    1.0000  *)
                (* 'MatrixExp6:22' omgtheta = so3ToVec(se3mat(1: 3, 1: 3)); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
                (* Returns the corresponding 3-vector (angular velocity). *)
                (* Example Input:  *)
                
                (* clear; clc; *)
                (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                (* omg = so3ToVec(so3mat)   *)
                
                (* Output: *)
                (* omg = *)
                (* 1 *)
                (* 2 *)
                (* 3 *)
                (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
                qs4[0] := V[0];
                qs4[1] := V[1];
                qs4[2] := V[2];
                (* 'MatrixExp6:23' if NearZero(norm(omgtheta)) *)
                (* *** BASIC HELPER FUNCTIONS *** *)
                (* Takes a scalar. *)
                (* Checks if the scalar is small enough to be neglected. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* near = -1e-7; *)
                (* judge = NearZero(near) *)
                
                (* Output: *)
                (* judge = *)
                (* 1 *)
                (* 'NearZero:15' judge = norm(near) < 1e-6; *)
                f_theta := norm(x := qs4);

                IF ABS(f_theta) < 1.0E-6 THEN 
                    (* 'MatrixExp6:24' T = [eye(3), se3mat(1: 3, 4); 0, 0, 0, 1]; *)
                    i0_eye();
                    tmp_0 := i0_eye.I;

                    FOR i_0 := 0 TO 2 DO 
                        R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                        a[R_tmp] := tmp_0[3 * i_0];
                        a[R_tmp + 1] := tmp_0[(3 * i_0) + 1];
                        a[R_tmp + 2] := tmp_0[(3 * i_0) + 2];
                        a[i_0 + 12] := se3mat[i_0 + 12];
                    END_FOR;

                    a[3] := 0.0;
                    a[7] := 0.0;
                    a[11] := 0.0;
                    a[15] := 1.0;
                ELSE 
                    (* 'MatrixExp6:25' else *)
                    (* 'MatrixExp6:26' [omghat, theta] = AxisAng3(omgtheta); *)
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes A 3-vector of exponential coordinates for rotation. *)
                    (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                    (* angle theta. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* expc3 = [1; 2; 3]; *)
                    (* [omghat, theta] = AxisAng3(expc3)   *)
                    
                    (* Output: *)
                    (* omghat = *)
                    (* 0.2673 *)
                    (* 0.5345 *)
                    (* 0.8018 *)
                    (* theta = *)
                    (* 3.7417 *)
                    (* 'AxisAng3:20' theta = norm(expc3); *)
                    (* 'AxisAng3:21' omghat = expc3 / theta; *)
                    (* 'MatrixExp6:27' omgmat = se3mat(1: 3, 1: 3) / theta; *)

                    FOR i_0 := 0 TO 2 DO 
                        omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                        omgmat[3 * i_0] := se3mat[omgmat_tmp] / f_theta;
                        omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / f_theta;
                        omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / f_theta;
                    END_FOR;

                    (* 'MatrixExp6:28' T = [MatrixExp3(se3mat(1: 3, 1: 3)), ... *)
                    (* 'MatrixExp6:29'          (eye(3) * theta + (1 - cos(theta)) * omgmat ... *)
                    (* 'MatrixExp6:30'           + (theta - sin(theta)) * omgmat * omgmat) ... *)
                    (* 'MatrixExp6:31'             * se3mat(1: 3, 4) / theta; *)
                    (* 'MatrixExp6:32'          0, 0, 0, 1]; *)
                    thetalist0_0 := 1.0 - COS(f_theta);
                    g_a := f_theta - SIN(f_theta);
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes a 3x3 so(3) representation of exponential coordinates. *)
                    (* Returns R in SO(3) that is achieved by rotating about omghat by theta  *)
                    (* from an initial orientation R = I. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                    (* R = MatrixExp3(so3mat)   *)
                    
                    (* Output: *)
                    (* R = *)
                    (* -0.6949    0.7135    0.0893 *)
                    (* -0.1920   -0.3038    0.9332 *)
                    (* 0.6930    0.6313    0.3481 *)
                    (* 'MatrixExp3:18' omgtheta = so3ToVec(so3mat); *)
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
                    (* Returns the corresponding 3-vector (angular velocity). *)
                    (* Example Input:  *)
                    
                    (* clear; clc; *)
                    (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                    (* omg = so3ToVec(so3mat)   *)
                    
                    (* Output: *)
                    (* omg = *)
                    (* 1 *)
                    (* 2 *)
                    (* 3 *)
                    (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
                    qs4[0] := V[0];
                    qs4[1] := V[1];
                    qs4[2] := V[2];
                    (* 'MatrixExp3:19' if NearZero(norm(omgtheta)) *)
                    (* *** BASIC HELPER FUNCTIONS *** *)
                    (* Takes a scalar. *)
                    (* Checks if the scalar is small enough to be neglected. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* near = -1e-7; *)
                    (* judge = NearZero(near) *)
                    
                    (* Output: *)
                    (* judge = *)
                    (* 1 *)
                    (* 'NearZero:15' judge = norm(near) < 1e-6; *)
                    j_theta := norm(x := qs4);

                    IF ABS(j_theta) < 1.0E-6 THEN 
                        (* 'MatrixExp3:20' R = eye(3); *)
                        i0_eye();
                        b_R := i0_eye.I;
                    ELSE 
                        (* 'MatrixExp3:21' else *)
                        (* 'MatrixExp3:22' [omghat, theta] = AxisAng3(omgtheta); *)
                        (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                        (* Takes A 3-vector of exponential coordinates for rotation. *)
                        (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                        (* angle theta. *)
                        (* Example Input: *)
                        
                        (* clear; clc; *)
                        (* expc3 = [1; 2; 3]; *)
                        (* [omghat, theta] = AxisAng3(expc3)   *)
                        
                        (* Output: *)
                        (* omghat = *)
                        (* 0.2673 *)
                        (* 0.5345 *)
                        (* 0.8018 *)
                        (* theta = *)
                        (* 3.7417 *)
                        (* 'AxisAng3:20' theta = norm(expc3); *)
                        (* 'AxisAng3:21' omghat = expc3 / theta; *)
                        (* 'MatrixExp3:23' omgmat = so3mat / theta; *)

                        FOR i_0 := 0 TO 2 DO 
                            omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                            b_omgmat[3 * i_0] := se3mat[omgmat_tmp] / j_theta;
                            b_omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / j_theta;
                            b_omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / j_theta;
                        END_FOR;

                        (* 'MatrixExp3:24' R = eye(3) + sin(theta) * omgmat + (1 - cos(theta)) * omgmat * omgmat; *)
                        l_a := SIN(j_theta);
                        x_tmp := COS(j_theta);
                        i0_eye();
                        tmp_0 := i0_eye.I;

                        FOR i_0 := 0 TO 2 DO 

                            FOR omgmat_tmp := 0 TO 2 DO 
                                R_tmp := (3 * omgmat_tmp) + i_0;
                                b_R[R_tmp] := (((((1.0 - x_tmp) * b_omgmat[i_0 + 3]) * b_omgmat[(3 * omgmat_tmp) + 1]) + (((1.0 - x_tmp) * b_omgmat[i_0]) * b_omgmat[3 * omgmat_tmp])) + ((b_omgmat[i_0 + 6] * (1.0 - x_tmp)) * b_omgmat[(3 * omgmat_tmp) + 2])) + ((b_omgmat[R_tmp] * l_a) + tmp_0[R_tmp]);
                            END_FOR;

                        END_FOR;

                    END_IF;


                    FOR i_0 := 0 TO 2 DO 
                        x_tmp := 0.0;

                        FOR omgmat_tmp := 0 TO 2 DO 
                            R_tmp := (3 * omgmat_tmp) + i_0;
                            x_tmp := ((((((omgmat[i_0 + 3] * g_a) * omgmat[(3 * omgmat_tmp) + 1]) + ((g_a * omgmat[i_0]) * omgmat[3 * omgmat_tmp])) + ((omgmat[i_0 + 6] * g_a) * omgmat[(3 * omgmat_tmp) + 2])) + ((SINT_TO_LREAL(p_a[R_tmp]) * f_theta) + (omgmat[R_tmp] * thetalist0_0))) * se3mat[omgmat_tmp + 12]) + x_tmp;
                            a[omgmat_tmp + (i_0 * 4)] := b_R[(3 * i_0) + omgmat_tmp];
                        END_FOR;

                        a[i_0 + 12] := x_tmp / f_theta;
                    END_FOR;

                    a[3] := 0.0;
                    a[7] := 0.0;
                    a[11] := 0.0;
                    a[15] := 1.0;
                END_IF;


                FOR i_0 := 0 TO 3 DO 
                    thetalist0_0 := a[i_0 + 4];
                    g_a := a[i_0];
                    l_a := a[i_0 + 8];
                    x_tmp := a[i_0 + 12];

                    FOR omgmat_tmp := 0 TO 3 DO 
                        R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                        a_0[i_0 + R_tmp] := (((Tsb[R_tmp + 1] * thetalist0_0) + (Tsb[R_tmp] * g_a)) + (Tsb[R_tmp + 2] * l_a)) + (Tsb[R_tmp + 3] * x_tmp);
                    END_FOR;

                END_FOR;


                FOR i_0 := 0 TO 15 DO 
                    Tsb[i_0] := a_0[i_0];
                END_FOR;

            END_FOR;

            (* 'IKinSpace:58' Vs = Adjoint(Tsb) * se3ToVec(MatrixLog6(TransInv(Tsb) * T)); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a transformation matrix T. *)
            (* Returns its inverse.  *)
            (* Uses the structure of transformation matrices to avoid taking a matrix *)
            (* inverse, for efficiency. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* invT = TransInv(T) *)
            
            (* Ouput: *)
            (* invT = *)
            (* 1     0     0     0 *)
            (* 0     0     1    -3 *)
            (* 0    -1     0     0 *)
            (* 0     0     0     1 *)
            (* 'TransInv:20' [R, p] = TransToRp(T); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes the transformation matrix T in SE(3)  *)
            (* Returns R: the corresponding rotation matrix *)
            (* p: the corresponding position vector . *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* [R, p] = TransToRp(T) *)
            
            (* Output: *)
            (* R = *)
            (* 1     0     0 *)
            (* 0     0    -1 *)
            (* 0     1     0 *)
            (* p = *)
            (* 0 *)
            (* 0 *)
            (* 3 *)
            (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
            (* 'TransToRp:23' p = T(1: 3, 4); *)
            (* 'TransInv:21' invT = [transpose(R), -transpose(R) * p; 0, 0, 0, 1]; *)

            FOR i_0 := 0 TO 2 DO 
                omgmat[3 * i_0] := Tsb[i_0];
                omgmat[(3 * i_0) + 1] := Tsb[i_0 + 4];
                omgmat[(3 * i_0) + 2] := Tsb[i_0 + 8];
            END_FOR;


            FOR i_0 := 0 TO 8 DO 
                b_R[i_0] :=  -omgmat[i_0];
            END_FOR;

            thetalist0_0 := Tsb[13];
            g_a := Tsb[12];
            l_a := Tsb[14];

            FOR i_0 := 0 TO 2 DO 
                omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                se3mat[omgmat_tmp] := omgmat[3 * i_0];
                se3mat[omgmat_tmp + 1] := omgmat[(3 * i_0) + 1];
                se3mat[omgmat_tmp + 2] := omgmat[(3 * i_0) + 2];
                se3mat[i_0 + 12] := ((b_R[i_0 + 3] * thetalist0_0) + (b_R[i_0] * g_a)) + (b_R[i_0 + 6] * l_a);
            END_FOR;

            se3mat[3] := 0.0;
            se3mat[7] := 0.0;
            se3mat[11] := 0.0;
            se3mat[15] := 1.0;

            FOR i_0 := 0 TO 3 DO 
                thetalist0_0 := se3mat[i_0 + 4];
                g_a := se3mat[i_0];
                l_a := se3mat[i_0 + 8];
                x_tmp := se3mat[i_0 + 12];

                FOR omgmat_tmp := 0 TO 3 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                    a_0[i_0 + R_tmp] := (((T[R_tmp + 1] * thetalist0_0) + (T[R_tmp] * g_a)) + (T[R_tmp + 2] * l_a)) + (T[R_tmp + 3] * x_tmp);
                END_FOR;

            END_FOR;

            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a transformation matrix T in SE(3). *)
            (* Returns the corresponding se(3) representation of exponential  *)
            (* coordinates. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* expmat = MatrixLog6(T) *)
            
            (* Output: *)
            (* expc6 = *)
            (* 0         0         0         0 *)
            (* 0         0   -1.5708    2.3562 *)
            (* 0    1.5708         0    2.3562 *)
            (* 0         0         0         0 *)
            (* 'MatrixLog6:19' [R, p] = TransToRp(T); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes the transformation matrix T in SE(3)  *)
            (* Returns R: the corresponding rotation matrix *)
            (* p: the corresponding position vector . *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* [R, p] = TransToRp(T) *)
            
            (* Output: *)
            (* R = *)
            (* 1     0     0 *)
            (* 0     0    -1 *)
            (* 0     1     0 *)
            (* p = *)
            (* 0 *)
            (* 0 *)
            (* 3 *)
            (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
            (* 'TransToRp:23' p = T(1: 3, 4); *)
            (* 'MatrixLog6:20' omgmat = MatrixLog3(R); *)

            FOR i_0 := 0 TO 2 DO 
                R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                b_R[3 * i_0] := a_0[R_tmp];
                b_R[(3 * i_0) + 1] := a_0[R_tmp + 1];
                b_R[(3 * i_0) + 2] := a_0[R_tmp + 2];
            END_FOR;

            i0_MatrixLog3(b_R := b_R);
            omgmat := i0_MatrixLog3.so3mat;
            (* 'MatrixLog6:21' if isequal(omgmat, zeros(3)) *)

            IF isequal(varargin_1 := omgmat, varargin_2 := tmp_2) THEN 
                (* 'MatrixLog6:22' expmat = [zeros(3), T(1: 3, 4); 0, 0, 0, 0]; *)

                FOR i_0 := 0 TO 2 DO 
                    omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                    se3mat[omgmat_tmp] := 0.0;
                    se3mat[omgmat_tmp + 1] := 0.0;
                    se3mat[omgmat_tmp + 2] := 0.0;
                    se3mat[i_0 + 12] := a_0[i_0 + 12];
                END_FOR;

                se3mat[3] := 0.0;
                se3mat[7] := 0.0;
                se3mat[11] := 0.0;
                se3mat[15] := 0.0;
            ELSE 
                (* 'MatrixLog6:23' else *)
                (* 'MatrixLog6:24' theta = acos((trace(R) - 1) / 2); *)
                b_theta := ACOS((((a_0[0] + a_0[5]) + a_0[10]) - 1.0) / 2.0);
                (* 'MatrixLog6:25' expmat = [omgmat, (eye(3) - omgmat / 2 ... *)
                (* 'MatrixLog6:26'                       + (1 / theta - cot(theta / 2) / 2) ... *)
                (* 'MatrixLog6:27'                         * omgmat * omgmat / theta) * p; *)
                (* 'MatrixLog6:28'               0, 0, 0, 0]; *)
                thetalist0_0 := (1.0 / b_theta) - ((1.0 / TAN(b_theta / 2.0)) / 2.0);
                i0_eye();
                tmp_0 := i0_eye.I;

                FOR i_0 := 0 TO 2 DO 
                    x_tmp := 0.0;

                    FOR omgmat_tmp := 0 TO 2 DO 
                        R_tmp := (3 * omgmat_tmp) + i_0;
                        x_tmp := (((((((omgmat[i_0 + 3] * thetalist0_0) * omgmat[(3 * omgmat_tmp) + 1]) + ((thetalist0_0 * omgmat[i_0]) * omgmat[3 * omgmat_tmp])) + ((omgmat[i_0 + 6] * thetalist0_0) * omgmat[(3 * omgmat_tmp) + 2])) / b_theta) + (tmp_0[R_tmp] - (omgmat[R_tmp] / 2.0))) * a_0[omgmat_tmp + 12]) + x_tmp;
                        se3mat[omgmat_tmp + (i_0 * 4)] := omgmat[(3 * i_0) + omgmat_tmp];
                    END_FOR;

                    se3mat[i_0 + 12] := x_tmp;
                END_FOR;

                se3mat[3] := 0.0;
                se3mat[7] := 0.0;
                se3mat[11] := 0.0;
                se3mat[15] := 0.0;
            END_IF;

            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes T a transformation matrix SE3.  *)
            (* Returns the corresponding 6x6 adjoint representation [AdT]. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* AdT = Adjoint(T) *)
            
            (* Output: *)
            (* AdT = *)
            (* 1     0     0     0     0     0 *)
            (* 0     0    -1     0     0     0 *)
            (* 0     1     0     0     0     0 *)
            (* 0     0     3     1     0     0 *)
            (* 3     0     0     0     0    -1 *)
            (* 0     0     0     0     1     0 *)
            (* 'Adjoint:20' [R, p] = TransToRp(T); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes the transformation matrix T in SE(3)  *)
            (* Returns R: the corresponding rotation matrix *)
            (* p: the corresponding position vector . *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* [R, p] = TransToRp(T) *)
            
            (* Output: *)
            (* R = *)
            (* 1     0     0 *)
            (* 0     0    -1 *)
            (* 0     1     0 *)
            (* p = *)
            (* 0 *)
            (* 0 *)
            (* 3 *)
            (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
            (* 'TransToRp:23' p = T(1: 3, 4); *)
            (* 'Adjoint:21' AdT = [R, zeros(3); VecToso3(p) * R, R]; *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 3-vector (angular velocity). *)
            (* Returns the skew symmetric matrix in so(3). *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* omg = [1; 2; 3]; *)
            (* so3mat = VecToso3(omg) *)
            
            (* Output: *)
            (* so3mat = *)
            (* 0    -3     2 *)
            (* 3     0    -1 *)
            (* -2     1     0 *)
            (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes se3mat a 4x4 se(3) matrix *)
            (* Returns the corresponding 6-vector (representing spatial velocity). *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* se3mat = [[0, -3, 2, 4]; [3, 0, -1, 5]; [-2, 1, 0, 6]; [0, 0, 0, 0]]; *)
            (* V = se3ToVec(se3mat) *)
            
            (* Output: *)
            (* V = *)
            (* 1 *)
            (* 2 *)
            (* 3 *)
            (* 4 *)
            (* 5 *)
            (* 6 *)
            (* 'se3ToVec:20' V = [se3mat(3, 2); se3mat(1, 3); se3mat(2, 1); se3mat(1: 3, 4)]; *)
            tmp_4[3] :=  -Tsb[14];
            tmp_4[6] := Tsb[13];
            tmp_4[1] := Tsb[14];
            tmp_4[7] :=  -Tsb[12];
            tmp_4[2] :=  -Tsb[13];
            tmp_4[5] := Tsb[12];

            FOR i_0 := 0 TO 2 DO 
                x_tmp := tmp_4[i_0 + 3];
                thetalist0_0 := tmp_4[i_0];
                g_a := tmp_4[i_0 + 6];

                FOR omgmat_tmp := 0 TO 2 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                    tmp_0[i_0 + (3 * omgmat_tmp)] := ((Tsb[R_tmp + 1] * x_tmp) + (Tsb[R_tmp] * thetalist0_0)) + (Tsb[R_tmp + 2] * g_a);
                    Tsb_0[omgmat_tmp + (6 * i_0)] := Tsb[(i_0 * 4) + omgmat_tmp];
                    Tsb_0[omgmat_tmp + (6 * (i_0 + 3))] := 0.0;
                END_FOR;

            END_FOR;

            V[0] := se3mat[6];
            V[1] := se3mat[8];
            V[2] := se3mat[1];

            FOR i_0 := 0 TO 2 DO 
                Tsb_0[(6 * i_0) + 3] := tmp_0[3 * i_0];
                omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                R_tmp := 6 * (i_0 + 3);
                Tsb_0[R_tmp + 3] := Tsb[omgmat_tmp];
                Tsb_0[(6 * i_0) + 4] := tmp_0[(3 * i_0) + 1];
                Tsb_0[R_tmp + 4] := Tsb[omgmat_tmp + 1];
                Tsb_0[(6 * i_0) + 5] := tmp_0[(3 * i_0) + 2];
                Tsb_0[R_tmp + 5] := Tsb[omgmat_tmp + 2];
                V[i_0 + 3] := se3mat[i_0 + 12];
            END_FOR;


            FOR i_0 := 0 TO 5 DO 
                thetalist0_0 := 0.0;

                FOR omgmat_tmp := 0 TO 5 DO 
                    thetalist0_0 := (Tsb_0[(6 * omgmat_tmp) + i_0] * V[omgmat_tmp]) + thetalist0_0;
                END_FOR;

                Vs[i_0] := thetalist0_0;
            END_FOR;

            (* 'IKinSpace:59' err = norm(Vs(1: 3)) > eomg || norm(Vs(4: 6)) > ev; *)
            se3mat_0[0] := Vs[0];
            se3mat_0[1] := Vs[1];
            se3mat_0[2] := Vs[2];

            IF norm(x := se3mat_0) <= 1.0E-5 THEN 
                se3mat_0[0] := Vs[3];
                se3mat_0[1] := Vs[4];
                se3mat_0[2] := Vs[5];

                IF norm(x := se3mat_0) <= 1.0E-7 THEN 
                    err := FALSE;
                END_IF;

            END_IF;

        END_WHILE;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'IKinSpace:61' success = ~ err; *)
        (* Assign them to the pre-allocated outputs *)
        (* '<S2>:1:67' thetaList    = thetaOut; *)
        (* '<S2>:1:68' success      = successOut; *)
        (* '<S2>:1:71' Js = JacobianSpace(SList,thetaList); *)
        (* *** CHAPTER 5: VELOCITY KINEMATICS AND STATICS *** *)
        (* Takes Slist: The joint screw axes in the space frame when the manipulator *)
        (* is at the home position, in the format of a matrix with the *)
        (* screw axes as the columns, *)
        (* thetalist: A list of joint coordinates.  *)
        (* Returns the corresponding space Jacobian (6xn real numbers). *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* Slist = [[0; 0; 1;   0; 0.2; 0.2], ... *)
        (* [1; 0; 0;   2;   0;   3], ... *)
        (* [0; 1; 0;   0;   2;   1], ... *)
        (* [1; 0; 0; 0.2; 0.3; 0.4]]; *)
        (* thetalist = [0.2; 1.1; 0.1; 1.2]; *)
        (* Js = JacobianSpace(Slist, thetalist) *)
        
        (* Output: *)
        (* Js = *)
        (* 0    0.9801   -0.0901    0.9575 *)
        (* 0    0.1987    0.4446    0.2849 *)
        (* 1.0000         0    0.8912   -0.0453 *)
        (* 0    1.9522   -2.2164   -0.5116 *)
        (* 0.2000    0.4365   -2.4371    2.7754 *)
        (* 0.2000    2.9603    3.2357    2.2251 *)
        (* 'JacobianSpace:27' Js = Slist; *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 29 DO 
            Js[i_0] := SList[i_0];
        END_FOR;

        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'JacobianSpace:28' T = eye(4); *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 15 DO 
            T[i_0] := 0.0;
        END_FOR;

        T[0] := 1.0;
        T[5] := 1.0;
        T[10] := 1.0;
        T[15] := 1.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* 'JacobianSpace:29' for i = 2: length(thetalist) *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        se3mat[0] := 0.0;
        se3mat[5] := 0.0;
        se3mat[10] := 0.0;
        se3mat[3] := 0.0;
        se3mat[7] := 0.0;
        se3mat[11] := 0.0;
        se3mat[15] := 0.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        tmp_0[0] := 0.0;
        tmp_0[4] := 0.0;
        tmp_0[8] := 0.0;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR b_i := 0 TO 3 DO 
            (* 'JacobianSpace:30' T = T * MatrixExp6(VecTose3(Slist(:, i - 1) * thetalist(i - 1))); *)
            thetalist0_0 := thetalist0[b_i];

            FOR i_0 := 0 TO 5 DO 
                V[i_0] := SList[(6 * b_i) + i_0] * thetalist0_0;
            END_FOR;

            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 6-vector (representing a spatial velocity). *)
            (* Returns the corresponding 4x4 se(3) matrix. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* V = [1; 2; 3; 4; 5; 6]; *)
            (* se3mat = VecTose3(V) *)
            
            (* Output: *)
            (* se3mat = *)
            (* 0    -3     2     4 *)
            (* 3     0    -1     5 *)
            (* -2     1     0     6 *)
            (* 0     0     0     0  *)
            (* 'VecTose3:18' se3mat = [VecToso3(V(1: 3)), V(4: 6); 0, 0, 0, 0]; *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 3-vector (angular velocity). *)
            (* Returns the skew symmetric matrix in so(3). *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* omg = [1; 2; 3]; *)
            (* so3mat = VecToso3(omg) *)
            
            (* Output: *)
            (* so3mat = *)
            (* 0    -3     2 *)
            (* 3     0    -1 *)
            (* -2     1     0 *)
            (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
            se3mat[4] :=  -V[2];
            se3mat[8] := V[1];
            se3mat[1] := V[2];
            se3mat[9] :=  -V[0];
            se3mat[2] :=  -V[1];
            se3mat[6] := V[0];
            se3mat[12] := V[3];
            se3mat[13] := V[4];
            se3mat[14] := V[5];
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a se(3) representation of exponential coordinates. *)
            (* Returns a T matrix in SE(3) that is achieved by traveling along/about the  *)
            (* screw axis S for a distance theta from an initial configuration T = I. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* se3mat = [ 0,      0,       0,      0; *)
            (* 0,      0, -1.5708, 2.3562; *)
            (* 0, 1.5708,       0, 2.3562; *)
            (* 0,      0,       0,      0] *)
            (* T = MatrixExp6(se3mat) *)
            
            (* Output: *)
            (* T = *)
            (* 1.0000         0         0         0 *)
            (* 0    0.0000   -1.0000   -0.0000 *)
            (* 0    1.0000    0.0000    3.0000 *)
            (* 0         0         0    1.0000  *)
            (* 'MatrixExp6:22' omgtheta = so3ToVec(se3mat(1: 3, 1: 3)); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
            (* Returns the corresponding 3-vector (angular velocity). *)
            (* Example Input:  *)
            
            (* clear; clc; *)
            (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
            (* omg = so3ToVec(so3mat)   *)
            
            (* Output: *)
            (* omg = *)
            (* 1 *)
            (* 2 *)
            (* 3 *)
            (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
            qs4[0] := V[0];
            qs4[1] := V[1];
            qs4[2] := V[2];
            (* 'MatrixExp6:23' if NearZero(norm(omgtheta)) *)
            (* *** BASIC HELPER FUNCTIONS *** *)
            (* Takes a scalar. *)
            (* Checks if the scalar is small enough to be neglected. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* near = -1e-7; *)
            (* judge = NearZero(near) *)
            
            (* Output: *)
            (* judge = *)
            (* 1 *)
            (* 'NearZero:15' judge = norm(near) < 1e-6; *)
            c_theta := norm(x := qs4);

            IF ABS(c_theta) < 1.0E-6 THEN 
                (* 'MatrixExp6:24' T = [eye(3), se3mat(1: 3, 4); 0, 0, 0, 1]; *)
                i0_eye();
                tmp := i0_eye.I;

                FOR i_0 := 0 TO 2 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                    a[R_tmp] := tmp[3 * i_0];
                    a[R_tmp + 1] := tmp[(3 * i_0) + 1];
                    a[R_tmp + 2] := tmp[(3 * i_0) + 2];
                    a[i_0 + 12] := se3mat[i_0 + 12];
                END_FOR;

                a[3] := 0.0;
                a[7] := 0.0;
                a[11] := 0.0;
                a[15] := 1.0;
            ELSE 
                (* 'MatrixExp6:25' else *)
                (* 'MatrixExp6:26' [omghat, theta] = AxisAng3(omgtheta); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes A 3-vector of exponential coordinates for rotation. *)
                (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                (* angle theta. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* expc3 = [1; 2; 3]; *)
                (* [omghat, theta] = AxisAng3(expc3)   *)
                
                (* Output: *)
                (* omghat = *)
                (* 0.2673 *)
                (* 0.5345 *)
                (* 0.8018 *)
                (* theta = *)
                (* 3.7417 *)
                (* 'AxisAng3:20' theta = norm(expc3); *)
                (* 'AxisAng3:21' omghat = expc3 / theta; *)
                (* 'MatrixExp6:27' omgmat = se3mat(1: 3, 1: 3) / theta; *)

                FOR i_0 := 0 TO 2 DO 
                    omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                    omgmat[3 * i_0] := se3mat[omgmat_tmp] / c_theta;
                    omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / c_theta;
                    omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / c_theta;
                END_FOR;

                (* 'MatrixExp6:28' T = [MatrixExp3(se3mat(1: 3, 1: 3)), ... *)
                (* 'MatrixExp6:29'          (eye(3) * theta + (1 - cos(theta)) * omgmat ... *)
                (* 'MatrixExp6:30'           + (theta - sin(theta)) * omgmat * omgmat) ... *)
                (* 'MatrixExp6:31'             * se3mat(1: 3, 4) / theta; *)
                (* 'MatrixExp6:32'          0, 0, 0, 1]; *)
                thetalist0_0 := 1.0 - COS(c_theta);
                g_a := c_theta - SIN(c_theta);
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3x3 so(3) representation of exponential coordinates. *)
                (* Returns R in SO(3) that is achieved by rotating about omghat by theta  *)
                (* from an initial orientation R = I. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                (* R = MatrixExp3(so3mat)   *)
                
                (* Output: *)
                (* R = *)
                (* -0.6949    0.7135    0.0893 *)
                (* -0.1920   -0.3038    0.9332 *)
                (* 0.6930    0.6313    0.3481 *)
                (* 'MatrixExp3:18' omgtheta = so3ToVec(so3mat); *)
                (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                (* Takes a 3x3 skew-symmetric matrix (an element of so(3)). *)
                (* Returns the corresponding 3-vector (angular velocity). *)
                (* Example Input:  *)
                
                (* clear; clc; *)
                (* so3mat = [[0, -3, 2]; [3, 0, -1]; [-2, 1, 0]]; *)
                (* omg = so3ToVec(so3mat)   *)
                
                (* Output: *)
                (* omg = *)
                (* 1 *)
                (* 2 *)
                (* 3 *)
                (* 'so3ToVec:17' omg = [so3mat(3, 2); so3mat(1, 3); so3mat(2, 1)]; *)
                qs4[0] := V[0];
                qs4[1] := V[1];
                qs4[2] := V[2];
                (* 'MatrixExp3:19' if NearZero(norm(omgtheta)) *)
                (* *** BASIC HELPER FUNCTIONS *** *)
                (* Takes a scalar. *)
                (* Checks if the scalar is small enough to be neglected. *)
                (* Example Input: *)
                
                (* clear; clc; *)
                (* near = -1e-7; *)
                (* judge = NearZero(near) *)
                
                (* Output: *)
                (* judge = *)
                (* 1 *)
                (* 'NearZero:15' judge = norm(near) < 1e-6; *)
                i_theta := norm(x := qs4);

                IF ABS(i_theta) < 1.0E-6 THEN 
                    (* 'MatrixExp3:20' R = eye(3); *)
                    i0_eye();
                    b_R := i0_eye.I;
                ELSE 
                    (* 'MatrixExp3:21' else *)
                    (* 'MatrixExp3:22' [omghat, theta] = AxisAng3(omgtheta); *)
                    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
                    (* Takes A 3-vector of exponential coordinates for rotation. *)
                    (* Returns the unit rotation axis omghat and the corresponding rotation  *)
                    (* angle theta. *)
                    (* Example Input: *)
                    
                    (* clear; clc; *)
                    (* expc3 = [1; 2; 3]; *)
                    (* [omghat, theta] = AxisAng3(expc3)   *)
                    
                    (* Output: *)
                    (* omghat = *)
                    (* 0.2673 *)
                    (* 0.5345 *)
                    (* 0.8018 *)
                    (* theta = *)
                    (* 3.7417 *)
                    (* 'AxisAng3:20' theta = norm(expc3); *)
                    (* 'AxisAng3:21' omghat = expc3 / theta; *)
                    (* 'MatrixExp3:23' omgmat = so3mat / theta; *)

                    FOR i_0 := 0 TO 2 DO 
                        omgmat_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                        b_omgmat[3 * i_0] := se3mat[omgmat_tmp] / i_theta;
                        b_omgmat[(3 * i_0) + 1] := se3mat[omgmat_tmp + 1] / i_theta;
                        b_omgmat[(3 * i_0) + 2] := se3mat[omgmat_tmp + 2] / i_theta;
                    END_FOR;

                    (* 'MatrixExp3:24' R = eye(3) + sin(theta) * omgmat + (1 - cos(theta)) * omgmat * omgmat; *)
                    l_a := SIN(i_theta);
                    x_tmp := COS(i_theta);
                    i0_eye();
                    tmp := i0_eye.I;

                    FOR i_0 := 0 TO 2 DO 

                        FOR omgmat_tmp := 0 TO 2 DO 
                            R_tmp := (3 * omgmat_tmp) + i_0;
                            b_R[R_tmp] := (((((1.0 - x_tmp) * b_omgmat[i_0 + 3]) * b_omgmat[(3 * omgmat_tmp) + 1]) + (((1.0 - x_tmp) * b_omgmat[i_0]) * b_omgmat[3 * omgmat_tmp])) + ((b_omgmat[i_0 + 6] * (1.0 - x_tmp)) * b_omgmat[(3 * omgmat_tmp) + 2])) + ((b_omgmat[R_tmp] * l_a) + tmp[R_tmp]);
                        END_FOR;

                    END_FOR;

                END_IF;


                FOR i_0 := 0 TO 2 DO 
                    x_tmp := 0.0;

                    FOR omgmat_tmp := 0 TO 2 DO 
                        R_tmp := (3 * omgmat_tmp) + i_0;
                        x_tmp := ((((((omgmat[i_0 + 3] * g_a) * omgmat[(3 * omgmat_tmp) + 1]) + ((g_a * omgmat[i_0]) * omgmat[3 * omgmat_tmp])) + ((omgmat[i_0 + 6] * g_a) * omgmat[(3 * omgmat_tmp) + 2])) + ((SINT_TO_LREAL(p_a[R_tmp]) * c_theta) + (omgmat[R_tmp] * thetalist0_0))) * se3mat[omgmat_tmp + 12]) + x_tmp;
                        a[omgmat_tmp + (i_0 * 4)] := b_R[(3 * i_0) + omgmat_tmp];
                    END_FOR;

                    a[i_0 + 12] := x_tmp / c_theta;
                END_FOR;

                a[3] := 0.0;
                a[7] := 0.0;
                a[11] := 0.0;
                a[15] := 1.0;
            END_IF;


            FOR i_0 := 0 TO 3 DO 
                thetalist0_0 := T[i_0 + 4];
                g_a := T[i_0];
                l_a := T[i_0 + 8];
                x_tmp := T[i_0 + 12];

                FOR omgmat_tmp := 0 TO 3 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                    M[i_0 + R_tmp] := (((a[R_tmp + 1] * thetalist0_0) + (a[R_tmp] * g_a)) + (a[R_tmp + 2] * l_a)) + (a[R_tmp + 3] * x_tmp);
                END_FOR;

            END_FOR;


            FOR i_0 := 0 TO 15 DO 
                T[i_0] := M[i_0];
            END_FOR;

            (* 'JacobianSpace:31' Js(:, i) = Adjoint(T) * Slist(:, i); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes T a transformation matrix SE3.  *)
            (* Returns the corresponding 6x6 adjoint representation [AdT]. *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* AdT = Adjoint(T) *)
            
            (* Output: *)
            (* AdT = *)
            (* 1     0     0     0     0     0 *)
            (* 0     0    -1     0     0     0 *)
            (* 0     1     0     0     0     0 *)
            (* 0     0     3     1     0     0 *)
            (* 3     0     0     0     0    -1 *)
            (* 0     0     0     0     1     0 *)
            (* 'Adjoint:20' [R, p] = TransToRp(T); *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes the transformation matrix T in SE(3)  *)
            (* Returns R: the corresponding rotation matrix *)
            (* p: the corresponding position vector . *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* T = [[1, 0, 0, 0]; [0, 0, -1, 0]; [0, 1, 0, 3]; [0, 0, 0, 1]]; *)
            (* [R, p] = TransToRp(T) *)
            
            (* Output: *)
            (* R = *)
            (* 1     0     0 *)
            (* 0     0    -1 *)
            (* 0     1     0 *)
            (* p = *)
            (* 0 *)
            (* 0 *)
            (* 3 *)
            (* 'TransToRp:22' R = T(1: 3, 1: 3); *)
            (* 'TransToRp:23' p = T(1: 3, 4); *)
            (* 'Adjoint:21' AdT = [R, zeros(3); VecToso3(p) * R, R]; *)
            (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
            (* Takes a 3-vector (angular velocity). *)
            (* Returns the skew symmetric matrix in so(3). *)
            (* Example Input: *)
            
            (* clear; clc; *)
            (* omg = [1; 2; 3]; *)
            (* so3mat = VecToso3(omg) *)
            
            (* Output: *)
            (* so3mat = *)
            (* 0    -3     2 *)
            (* 3     0    -1 *)
            (* -2     1     0 *)
            (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
            tmp_0[3] :=  -T[14];
            tmp_0[6] := T[13];
            tmp_0[1] := T[14];
            tmp_0[7] :=  -T[12];
            tmp_0[2] :=  -T[13];
            tmp_0[5] := T[12];

            FOR i_0 := 0 TO 2 DO 
                x_tmp := tmp_0[i_0 + 3];
                thetalist0_0 := tmp_0[i_0];
                g_a := tmp_0[i_0 + 6];

                FOR omgmat_tmp := 0 TO 2 DO 
                    R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(omgmat_tmp), 2));
                    tmp[i_0 + (3 * omgmat_tmp)] := ((T[R_tmp + 1] * x_tmp) + (T[R_tmp] * thetalist0_0)) + (T[R_tmp + 2] * g_a);
                    Tsb_0[omgmat_tmp + (6 * i_0)] := T[(i_0 * 4) + omgmat_tmp];
                    Tsb_0[omgmat_tmp + (6 * (i_0 + 3))] := 0.0;
                END_FOR;

            END_FOR;


            FOR i_0 := 0 TO 2 DO 
                Tsb_0[(6 * i_0) + 3] := tmp[3 * i_0];
                R_tmp := DWORD_TO_DINT(SHL(DINT_TO_DWORD(i_0), 2));
                omgmat_tmp := 6 * (i_0 + 3);
                Tsb_0[omgmat_tmp + 3] := T[R_tmp];
                Tsb_0[(6 * i_0) + 4] := tmp[(3 * i_0) + 1];
                Tsb_0[omgmat_tmp + 4] := T[R_tmp + 1];
                Tsb_0[(6 * i_0) + 5] := tmp[(3 * i_0) + 2];
                Tsb_0[omgmat_tmp + 5] := T[R_tmp + 2];
            END_FOR;


            FOR i_0 := 0 TO 5 DO 
                thetalist0_0 := 0.0;

                FOR omgmat_tmp := 0 TO 5 DO 
                    thetalist0_0 := (SList[((b_i + 1) * 6) + omgmat_tmp] * Tsb_0[(6 * omgmat_tmp) + i_0]) + thetalist0_0;
                END_FOR;

                Js[i_0 + (6 * (b_i + 1))] := thetalist0_0;
            END_FOR;

        END_FOR;

        (* '<S2>:1:72' Js_pinv = pinv(Js); *)
        (* '<S2>:1:73' xyzDot = [0; *)
        (* '<S2>:1:74'          0; *)
        (* '<S2>:1:75'          0; *)
        (* '<S2>:1:76'          xDot; *)
        (* '<S2>:1:77'          yDot; *)
        (* '<S2>:1:78'          zDot *)
        (* '<S2>:1:79'          ]; *)
        (* '<S2>:1:81' thetaListDot = Js_pinv*xyzDot; *)
        i0_pinv(A := Js);
        tmp_1 := i0_pinv.X;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)
        V[0] := 0.0;
        V[1] := 0.0;
        V[2] := 0.0;
        V[3] := fXDotRef;
        V[4] := fYDotRef;
        V[5] := fZDotRef;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* MATLAB Function: '<S1>/inverceKinematics' *)

        FOR i_0 := 0 TO 4 DO 
            x_tmp := 0.0;

            FOR omgmat_tmp := 0 TO 5 DO 
                x_tmp := (tmp_1[(5 * omgmat_tmp) + i_0] * V[omgmat_tmp]) + x_tmp;
            END_FOR;

            rtb_thetaListDot[i_0] := x_tmp;
        END_FOR;

        (* Update for Memory: '<S1>/Memory' *)
        Memory_PreviousInput[0] := thetalist0[3];
        Memory_PreviousInput[1] := thetalist0[4];
        (* Update for Memory: '<S1>/Memory1' *)
        Memory1_PreviousInput := fKnuckleFeedback;
        (* Update for Memory: '<S1>/Memory2' *)
        Memory2_PreviousInput := fMainFeedback;
        (* Update for Memory: '<S1>/Memory3' *)
        Memory3_PreviousInput := fSlewFeedback;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        

        (* Outport: '<Root>/fSlewRef' *)
        fSlewRef := thetalist0[0];
        (* Outport: '<Root>/fMainRef' *)
        fMainRef := thetalist0[1];
        (* Outport: '<Root>/fKnuckleRef' *)
        fKnuckleRef := thetalist0[2];
        (* Outport: '<Root>/fSlewVelRef' *)
        fSlewVelRef := rtb_thetaListDot[0];
        (* Outport: '<Root>/fMainVelRef' *)
        fMainVelRef := rtb_thetaListDot[1];
        (* Outport: '<Root>/fKnuckleVelRef' *)
        fKnuckleVelRef := rtb_thetaListDot[2];
        (* Outputs for Atomic SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
        (* Outport: '<Root>/success' incorporates:
         *  MATLAB Function: '<S1>/inverceKinematics' *)
        success :=  NOT err;
        (* End of Outputs for SubSystem: '<Root>/FB_InverceKinematicsVaribleTelescope' *)
END_CASE;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="isequal" pouType="function">
        <interface>
          <returnType>
            <BOOL/>
          </returnType>
          <inputVars>
            <variable name="varargin_1">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="varargin_2">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="b_b_p">
              <type>
                <BOOL/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="exitg1">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
isequal := FALSE;
b_b_p := TRUE;
k := 0;
REPEAT 
    exitg1 := 0;

    IF k < 9 THEN 

        IF varargin_1[k] <> varargin_2[k] THEN 
            b_b_p := FALSE;
            exitg1 := 1;
        ELSE 
            k := k + 1;
        END_IF;

    ELSE 
        exitg1 := 1;
    END_IF;

UNTIL NOT(exitg1 = 0)
END_REPEAT;

IF b_b_p THEN 
    isequal := TRUE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="norm" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="2"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="scale">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="absxk">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="t">
              <type>
                <LREAL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
scale := 3.3121686421112381E-170;
absxk := ABS(x[0]);

IF absxk > 3.3121686421112381E-170 THEN 
    norm := 1.0;
    scale := absxk;
ELSE 
    t := absxk / 3.3121686421112381E-170;
    norm := t * t;
END_IF;

absxk := ABS(x[1]);

IF absxk > scale THEN 
    t := scale / absxk;
    norm := ((norm * t) * t) + 1.0;
    scale := absxk;
ELSE 
    t := absxk / scale;
    norm := (t * t) + norm;
END_IF;

absxk := ABS(x[2]);

IF absxk > scale THEN 
    t := scale / absxk;
    norm := ((norm * t) * t) + 1.0;
    scale := absxk;
ELSE 
    t := absxk / scale;
    norm := (t * t) + norm;
END_IF;

norm := scale * SQRT(norm);

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="pinv" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="A">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="X">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="V">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_r">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="vcol">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="U">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_s">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="j">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="absx">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ia">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="b">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="ib">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="b_ic">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="ln2x">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="e">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="exitg1">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp2">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="i0_svd">
              <type>
                <derived name="svd"/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
b_r := -1;

FOR vcol := 0 TO 29 DO 
    X[vcol] := 0.0;
END_FOR;

i0_svd(A := A);
U := i0_svd.U;
b_s := i0_svd.b_s;
V := i0_svd.V;
absx := ABS(b_s[0]);

IF absx < 2.2250738585072014E-307 THEN 
    ln2x := 2.2250738585072014E-307;
ELSE 
    temp2 := LN(absx);
    ln2x := rt_floord(u := temp2 / 0.69314718055994529);
    vcol := TRUNC(ln2x) - 1;
    e :=  -TRUNC(ln2x);

    IF ( -TRUNC(ln2x)) < -1022 THEN 
        absx := absx * 1.90109156629516E-211;
        e := 700 - TRUNC(ln2x);

        IF (700 - TRUNC(ln2x)) < -1022 THEN 
            absx := absx * 1.90109156629516E-211;
            e := 1400 - TRUNC(ln2x);
        END_IF;

    ELSIF ( -TRUNC(ln2x)) > 1023 THEN 
        absx := absx * 5.2601359015483735E+210;
        e := ( -TRUNC(ln2x)) - 700;

        IF (( -TRUNC(ln2x)) - 700) > 1023 THEN 
            absx := absx * 5.2601359015483735E+210;
            e := ( -TRUNC(ln2x)) - 1400;
        END_IF;

    END_IF;

    absx := absx * EXPT(2.0, DINT_TO_LREAL(e));

    IF absx < 0.5 THEN 
        vcol := TRUNC(ln2x) - 2;
    ELSIF absx >= 1.0 THEN 
        vcol := TRUNC(ln2x);
    END_IF;

    ln2x := rt_ldexp_U1d_U2s32_Yd_s_pw(u0 := 1.0, u1 := vcol - 52);
END_IF;

ln2x := 6.0 * ln2x;
vcol := 0;
REPEAT 
    exitg1 := 0;

    IF vcol < 5 THEN 

        IF b_s[vcol] <= ln2x THEN 
            exitg1 := 1;
        ELSE 
            b_r := b_r + 1;
            vcol := vcol + 1;
        END_IF;

    ELSE 
        exitg1 := 1;
    END_IF;

UNTIL NOT(exitg1 = 0)
END_REPEAT;

IF (b_r + 1) > 0 THEN 
    vcol := 0;
    j := 0;
    WHILE j <= b_r DO
        ln2x := 1.0 / b_s[j];
        e := vcol;
        WHILE (e + 1) <= (vcol + 5) DO
            V[e] := ln2x * V[e];
            e := e + 1;
        END_WHILE;
        vcol := vcol + 5;
        j := j + 1;
    END_WHILE;

    FOR vcol := 0 TO 29 DO 
        X[vcol] := 0.0;
    END_FOR;

    vcol := 0;

    FOR j := 0 TO 26 BY 5 DO 
        e := j;
        WHILE (e + 1) <= (j + 5) DO
            X[e] := 0.0;
            e := e + 1;
        END_WHILE;
    END_FOR;


    FOR j := 0 TO 26 BY 5 DO 
        e := -1;
        vcol := vcol + 1;
        b := (6 * b_r) + vcol;
        ib := vcol;
        WHILE ib <= b DO
            ia := e;
            b_ic := j;
            WHILE (b_ic + 1) <= (j + 5) DO
                ia := ia + 1;
                X[b_ic] := (U[ib - 1] * V[ia]) + X[b_ic];
                b_ic := b_ic + 1;
            END_WHILE;
            e := e + 5;
            ib := ib + 6;
        END_WHILE;
    END_FOR;

END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="svd" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="A">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="U">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_s">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="V">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="b_A">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="b_b_s">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="e">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="work">
              <type>
                <array>
                  <dimension lower="0" upper="5"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="Vf">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="doscale">
              <type>
                <BOOL/>
              </type>
            </variable>
            <variable name="cscale">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="anrm">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="qq">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="apply_transform">
              <type>
                <BOOL/>
              </type>
            </variable>
            <variable name="nrm">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="qjj">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="qp1jj">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="m">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="qp1q">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="rt">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ztest">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="smm1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="emm1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="sqds">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="shift">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="j_ii">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="exitg1">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp3">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp4">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp5">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp6">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp7">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp8">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp9">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp10">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp11">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp12">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp13">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp14">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp15">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp16">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="i0_xzlascl">
              <type>
                <derived name="xzlascl"/>
              </type>
            </variable>
            <variable name="i0_xscal">
              <type>
                <derived name="xscal"/>
              </type>
            </variable>
            <variable name="i0_xscal_f">
              <type>
                <derived name="xscal_f"/>
              </type>
            </variable>
            <variable name="i0_xaxpy_po">
              <type>
                <derived name="xaxpy_po"/>
              </type>
            </variable>
            <variable name="i0_xaxpy_p">
              <type>
                <derived name="xaxpy_p"/>
              </type>
            </variable>
            <variable name="i0_xaxpy">
              <type>
                <derived name="xaxpy"/>
              </type>
            </variable>
            <variable name="i0_xaxpy_poj">
              <type>
                <derived name="xaxpy_poj"/>
              </type>
            </variable>
            <variable name="i0_xscal_fb">
              <type>
                <derived name="xscal_fb"/>
              </type>
            </variable>
            <variable name="i0_xscal_fbq">
              <type>
                <derived name="xscal_fbq"/>
              </type>
            </variable>
            <variable name="i0_xswap">
              <type>
                <derived name="xswap"/>
              </type>
            </variable>
            <variable name="i0_xswap_k">
              <type>
                <derived name="xswap_k"/>
              </type>
            </variable>
            <variable name="i0_xrotg">
              <type>
                <derived name="xrotg"/>
              </type>
            </variable>
            <variable name="i0_xrot">
              <type>
                <derived name="xrot"/>
              </type>
            </variable>
            <variable name="i0_xrot_l">
              <type>
                <derived name="xrot_l"/>
              </type>
            </variable>
            <variable name="i0_xzlascl_g">
              <type>
                <derived name="xzlascl_g"/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

FOR m := 0 TO 29 DO 
    b_A[m] := A[m];
END_FOR;


FOR m := 0 TO 4 DO 
    b_b_s[m] := 0.0;
    e[m] := 0.0;
END_FOR;


FOR m := 0 TO 5 DO 
    work[m] := 0.0;
END_FOR;


FOR m := 0 TO 29 DO 
    U[m] := 0.0;
END_FOR;


FOR m := 0 TO 24 DO 
    Vf[m] := 0.0;
END_FOR;

doscale := FALSE;
anrm := xzlangeM(x := A);
cscale := anrm;

IF (anrm > 0.0) AND (anrm < 6.7178761075670888E-139) THEN 
    doscale := TRUE;
    cscale := 6.7178761075670888E-139;
    i0_xzlascl(cfrom := anrm, cto := cscale, m := 6, b_n := 5, A := b_A, iA0 := 1, lda := 6);
ELSIF anrm > 1.4885657073574029E+138 THEN 
    doscale := TRUE;
    cscale := 1.4885657073574029E+138;
    i0_xzlascl(cfrom := anrm, cto := cscale, m := 6, b_n := 5, A := b_A, iA0 := 1, lda := 6);
END_IF;


FOR m := 0 TO 4 DO 
    qq := (6 * m) + m;
    apply_transform := FALSE;
    nrm := xnrm2(b_n := 6 - m, x := b_A, ix0 := qq + 1);

    IF nrm > 0.0 THEN 
        apply_transform := TRUE;

        IF b_A[qq] < 0.0 THEN 
            ztest :=  -nrm;
            b_b_s[m] :=  -nrm;
        ELSE 
            ztest := nrm;
            b_b_s[m] := nrm;
        END_IF;


        IF ABS(ztest) >= 1.0020841800044864E-292 THEN 
            i0_xscal(b_n := 6 - m, a := 1.0 / ztest, x := b_A, ix0 := qq + 1);
        ELSE 
            qp1q := (qq - m) + 6;
            qjj := qq;
            WHILE (qjj + 1) <= qp1q DO
                b_A[qjj] := b_A[qjj] / b_b_s[m];
                qjj := qjj + 1;
            END_WHILE;
        END_IF;

        b_A[qq] := b_A[qq] + 1.0;
        b_b_s[m] :=  -b_b_s[m];
    ELSE 
        b_b_s[m] := 0.0;
    END_IF;

    qp1q := m + 1;
    WHILE (qp1q + 1) < 6 DO
        qjj := (6 * qp1q) + m;

        IF apply_transform THEN 
            temp3 := xdotc(b_n := 6 - m, x := b_A, ix0 := qq + 1, y := b_A, iy0 := qjj + 1);
            i0_xaxpy(b_n := 6 - m, a :=  -(temp3 / b_A[m + (6 * m)]), ix0 := qq + 1, y := b_A, iy0 := qjj + 1);
        END_IF;

        e[qp1q] := b_A[qjj];
        qp1q := qp1q + 1;
    END_WHILE;
    qq := m;
    WHILE (qq + 1) < 7 DO
        U[qq + (6 * m)] := b_A[(6 * m) + qq];
        qq := qq + 1;
    END_WHILE;

    IF (m + 1) <= 3 THEN 
        nrm := xnrm2_j(b_n := 4 - m, x := e, ix0 := m + 2);

        IF nrm = 0.0 THEN 
            e[m] := 0.0;
        ELSE 

            IF e[m + 1] < 0.0 THEN 
                e[m] :=  -nrm;
            ELSE 
                e[m] := nrm;
            END_IF;

            nrm := e[m];

            IF ABS(e[m]) >= 1.0020841800044864E-292 THEN 
                i0_xscal_f(b_n := 4 - m, a := 1.0 / e[m], x := e, ix0 := m + 2);
            ELSE 
                qq := m + 1;
                WHILE (qq + 1) <= 5 DO
                    e[qq] := e[qq] / nrm;
                    qq := qq + 1;
                END_WHILE;
            END_IF;

            e[m + 1] := e[m + 1] + 1.0;
            e[m] :=  -e[m];
            qq := m + 1;
            WHILE (qq + 1) < 7 DO
                work[qq] := 0.0;
                qq := qq + 1;
            END_WHILE;
            qq := m + 1;
            WHILE (qq + 1) < 6 DO
                i0_xaxpy_p(b_n := 5 - m, a := e[qq], x := b_A, ix0 := (m + (6 * qq)) + 2, y := work, iy0 := m + 2);
                qq := qq + 1;
            END_WHILE;
            qq := m + 1;
            WHILE (qq + 1) < 6 DO
                i0_xaxpy_po(b_n := 5 - m, a := ( -e[qq]) / e[m + 1], x := work, ix0 := m + 2, y := b_A, iy0 := (m + (6 * qq)) + 2);
                qq := qq + 1;
            END_WHILE;
        END_IF;

        qq := m + 1;
        WHILE (qq + 1) < 6 DO
            Vf[qq + (5 * m)] := e[qq];
            qq := qq + 1;
        END_WHILE;
    END_IF;

END_FOR;

m := 3;
e[3] := b_A[27];
e[4] := 0.0;

FOR qp1q := 4 TO 0 BY -1 DO 
    qq := (6 * qp1q) + qp1q;

    IF b_b_s[qp1q] <> 0.0 THEN 
        qp1jj := qp1q + 1;
        WHILE (qp1jj + 1) < 6 DO
            qjj := ((6 * qp1jj) + qp1q) + 1;
            temp4 := xdotc(b_n := 6 - qp1q, x := U, ix0 := qq + 1, y := U, iy0 := qjj);
            i0_xaxpy(b_n := 6 - qp1q, a :=  -(temp4 / U[qq]), ix0 := qq + 1, y := U, iy0 := qjj);
            qp1jj := qp1jj + 1;
        END_WHILE;
        qjj := qp1q;
        WHILE (qjj + 1) < 7 DO
            qp1jj := (6 * qp1q) + qjj;
            U[qp1jj] :=  -U[qp1jj];
            qjj := qjj + 1;
        END_WHILE;
        U[qq] := U[qq] + 1.0;
        qq := 0;
        WHILE qq <= (qp1q - 1) DO
            U[qq + (6 * qp1q)] := 0.0;
            qq := qq + 1;
        END_WHILE;
    ELSE 

        FOR qjj := 0 TO 5 DO 
            U[qjj + (6 * qp1q)] := 0.0;
        END_FOR;

        U[qq] := 1.0;
    END_IF;

END_FOR;


FOR qq := 4 TO 0 BY -1 DO 

    IF (qq + 1) <= 3 THEN 

        IF e[qq] <> 0.0 THEN 
            qp1q := ((5 * qq) + qq) + 2;
            qjj := qq + 1;
            WHILE (qjj + 1) < 6 DO
                qp1jj := ((5 * qjj) + qq) + 2;
                temp5 := xdotc_d(b_n := 4 - qq, x := Vf, ix0 := qp1q, y := Vf, iy0 := qp1jj);
                i0_xaxpy_poj(b_n := 4 - qq, a :=  -(temp5 / Vf[qp1q - 1]), ix0 := qp1q, y := Vf, iy0 := qp1jj);
                qjj := qjj + 1;
            END_WHILE;
        END_IF;

    END_IF;


    FOR qp1q := 0 TO 4 DO 
        Vf[qp1q + (5 * qq)] := 0.0;
    END_FOR;

    Vf[qq + (5 * qq)] := 1.0;
END_FOR;


FOR qq := 0 TO 4 DO 
    ztest := b_b_s[qq];

    IF ztest <> 0.0 THEN 
        rt := ABS(ztest);
        nrm := ztest / rt;
        b_b_s[qq] := rt;

        IF (qq + 1) < 5 THEN 
            e[qq] := e[qq] / nrm;
        END_IF;

        i0_xscal_fb(a := nrm, x := U, ix0 := (6 * qq) + 1);
    END_IF;


    IF (qq + 1) < 5 THEN 
        nrm := e[qq];

        IF nrm <> 0.0 THEN 
            rt := ABS(nrm);
            nrm := rt / nrm;
            e[qq] := rt;
            b_b_s[qq + 1] := b_b_s[qq + 1] * nrm;
            i0_xscal_fbq(a := nrm, x := Vf, ix0 := (5 * (qq + 1)) + 1);
        END_IF;

    END_IF;

END_FOR;

qq := 0;
nrm := 0.0;

FOR qp1q := 0 TO 4 DO 
    temp6 := ABS(b_b_s[qp1q]);
    temp7 := ABS(e[qp1q]);
    temp8 := MAX(temp6, temp7);
    nrm := MAX(nrm, temp8);
END_FOR;

WHILE ((m + 2) > 0) AND (qq < 75) DO
    qp1jj := m + 1;
    REPEAT 
        exitg1 := 0;
        qp1q := qp1jj;

        IF qp1jj = 0 THEN 
            exitg1 := 1;
        ELSE 
            rt := ABS(e[qp1jj - 1]);

            IF rt <= ((ABS(b_b_s[qp1jj - 1]) + ABS(b_b_s[qp1jj])) * 2.2204460492503131E-16) THEN 
                e[qp1jj - 1] := 0.0;
                exitg1 := 1;
            ELSIF (rt <= 1.0020841800044864E-292) OR ((qq > 20) AND (rt <= (2.2204460492503131E-16 * nrm))) THEN 
                e[qp1jj - 1] := 0.0;
                exitg1 := 1;
            ELSE 
                qp1jj := qp1jj - 1;
            END_IF;

        END_IF;

    UNTIL NOT(exitg1 = 0)
    END_REPEAT;

    IF (m + 1) = qp1jj THEN 
        qp1jj := 4;
    ELSE 
        qjj := m + 2;
        j_ii := m + 2;
        REPEAT 
            exitg1 := 0;

            IF j_ii >= qp1jj THEN 
                qjj := j_ii;

                IF j_ii = qp1jj THEN 
                    exitg1 := 1;
                ELSE 
                    rt := 0.0;

                    IF j_ii < (m + 2) THEN 
                        rt := ABS(e[j_ii - 1]);
                    END_IF;


                    IF j_ii > (qp1jj + 1) THEN 
                        rt := ABS(e[j_ii - 2]) + rt;
                    END_IF;

                    ztest := ABS(b_b_s[j_ii - 1]);

                    IF (ztest <= (2.2204460492503131E-16 * rt)) OR (ztest <= 1.0020841800044864E-292) THEN 
                        b_b_s[j_ii - 1] := 0.0;
                        exitg1 := 1;
                    ELSE 
                        j_ii := j_ii - 1;
                    END_IF;

                END_IF;

            ELSE 
                exitg1 := 1;
            END_IF;

        UNTIL NOT(exitg1 = 0)
        END_REPEAT;

        IF qjj = qp1jj THEN 
            qp1jj := 3;
        ELSIF (m + 2) = qjj THEN 
            qp1jj := 1;
        ELSE 
            qp1jj := 2;
            qp1q := qjj;
        END_IF;

    END_IF;


    CASE qp1jj OF
        1: 
            rt := e[m];
            e[m] := 0.0;
            qjj := m;
            WHILE (qjj + 1) >= (qp1q + 1) DO
                i0_xrotg(a := b_b_s[qjj], b := rt);
                ztest := i0_xrotg.c;
                sqds := i0_xrotg.b_s;

                IF (qjj + 1) > (qp1q + 1) THEN 
                    emm1 := e[qjj - 1];
                    rt := emm1 * ( -sqds);
                    e[qjj - 1] := emm1 * ztest;
                END_IF;

                i0_xrot(x := Vf, ix0 := (5 * qjj) + 1, iy0 := (5 * (m + 1)) + 1, c := ztest, b_s := sqds);
                qjj := qjj - 1;
            END_WHILE;
        2: 
            rt := e[qp1q - 1];
            e[qp1q - 1] := 0.0;
            qjj := qp1q;
            WHILE (qjj + 1) <= (m + 2) DO
                i0_xrotg(a := b_b_s[qjj], b := rt);
                ztest := i0_xrotg.c;
                sqds := i0_xrotg.b_s;
                rt := ( -sqds) * e[qjj];
                e[qjj] := e[qjj] * ztest;
                i0_xrot_l(x := U, ix0 := (6 * qjj) + 1, iy0 := (6 * (qp1q - 1)) + 1, c := ztest, b_s := sqds);
                qjj := qjj + 1;
            END_WHILE;
        3: 
            rt := b_b_s[m + 1];
            temp9 := ABS(rt);
            temp10 := ABS(b_b_s[m]);
            temp11 := MAX(temp9, temp10);
            temp12 := ABS(e[m]);
            temp13 := MAX(temp11, temp12);
            temp14 := ABS(b_b_s[qp1q]);
            temp15 := MAX(temp13, temp14);
            temp16 := ABS(e[qp1q]);
            ztest := MAX(temp15, temp16);
            rt := rt / ztest;
            smm1 := b_b_s[m] / ztest;
            emm1 := e[m] / ztest;
            sqds := b_b_s[qp1q] / ztest;
            smm1 := (((smm1 + rt) * (smm1 - rt)) + (emm1 * emm1)) / 2.0;
            emm1 := rt * emm1;
            emm1 := emm1 * emm1;

            IF (smm1 <> 0.0) OR (emm1 <> 0.0) THEN 
                shift := SQRT((smm1 * smm1) + emm1);

                IF smm1 < 0.0 THEN 
                    shift :=  -shift;
                END_IF;

                shift := emm1 / (smm1 + shift);
            ELSE 
                shift := 0.0;
            END_IF;

            rt := ((sqds + rt) * (sqds - rt)) + shift;
            ztest := (e[qp1q] / ztest) * sqds;
            qjj := qp1q + 1;
            WHILE qjj <= (m + 1) DO
                i0_xrotg(a := rt, b := ztest);
                sqds := i0_xrotg.c;
                smm1 := i0_xrotg.b_s;

                IF qjj > (qp1q + 1) THEN 
                    e[qjj - 2] := rt;
                END_IF;

                emm1 := e[qjj - 1];
                rt := b_b_s[qjj - 1];
                e[qjj - 1] := (emm1 * sqds) - (rt * smm1);
                ztest := smm1 * b_b_s[qjj];
                b_b_s[qjj] := b_b_s[qjj] * sqds;
                i0_xrot(x := Vf, ix0 := (5 * (qjj - 1)) + 1, iy0 := (5 * qjj) + 1, c := sqds, b_s := smm1);
                b_b_s[qjj - 1] := (rt * sqds) + (emm1 * smm1);
                i0_xrotg(a := b_b_s[qjj - 1], b := ztest);
                sqds := i0_xrotg.c;
                smm1 := i0_xrotg.b_s;
                rt := (e[qjj - 1] * sqds) + (smm1 * b_b_s[qjj]);
                b_b_s[qjj] := (e[qjj - 1] * ( -smm1)) + (sqds * b_b_s[qjj]);
                ztest := smm1 * e[qjj];
                e[qjj] := e[qjj] * sqds;
                i0_xrot_l(x := U, ix0 := (6 * (qjj - 1)) + 1, iy0 := (6 * qjj) + 1, c := sqds, b_s := smm1);
                qjj := qjj + 1;
            END_WHILE;
            e[m] := rt;
            qq := qq + 1;
        ELSE

            IF b_b_s[qp1q] < 0.0 THEN 
                b_b_s[qp1q] :=  -b_b_s[qp1q];
                i0_xscal_fbq(a := -1.0, x := Vf, ix0 := (5 * qp1q) + 1);
            END_IF;

            qq := qp1q + 1;
            REPEAT 
                exitg1 := 0;

                IF (qp1q + 1) < 5 THEN 

                    IF b_b_s[qp1q] < b_b_s[qq] THEN 
                        rt := b_b_s[qp1q];
                        b_b_s[qp1q] := b_b_s[qq];
                        b_b_s[qq] := rt;
                        i0_xswap(x := Vf, ix0 := (5 * qp1q) + 1, iy0 := (5 * (qp1q + 1)) + 1);
                        i0_xswap_k(x := U, ix0 := (6 * qp1q) + 1, iy0 := (6 * (qp1q + 1)) + 1);
                        qp1q := qq;
                        qq := qq + 1;
                    ELSE 
                        exitg1 := 1;
                    END_IF;

                ELSE 
                    exitg1 := 1;
                END_IF;

            UNTIL NOT(exitg1 = 0)
            END_REPEAT;
            qq := 0;
            m := m - 1;
    END_CASE;

END_WHILE;

FOR m := 0 TO 4 DO 
    b_s[m] := b_b_s[m];
END_FOR;


IF doscale THEN 
    i0_xzlascl_g(cfrom := cscale, cto := anrm, m := 5, b_n := 1, A := b_s, iA0 := 1, lda := 5);
END_IF;


FOR m := 0 TO 24 DO 
    V[m] := Vf[m];
END_FOR;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xzlangeM" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="absxk">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
xzlangeM := 0.0;

FOR k := 0 TO 29 DO 
    absxk := ABS(x[k]);

    IF absxk > xzlangeM THEN 
        xzlangeM := absxk;
    END_IF;

END_FOR;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xnrm2" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="scale">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="kend">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="absxk">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="t">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
xnrm2 := 0.0;

IF b_n >= 1 THEN 

    IF b_n = 1 THEN 
        xnrm2 := ABS(x[ix0 - 1]);
    ELSE 
        scale := 3.3121686421112381E-170;
        kend := (ix0 + b_n) - 1;
        k := ix0;
        WHILE k <= kend DO
            absxk := ABS(x[k - 1]);

            IF absxk > scale THEN 
                t := scale / absxk;
                xnrm2 := ((xnrm2 * t) * t) + 1.0;
                scale := absxk;
            ELSE 
                t := absxk / scale;
                xnrm2 := (t * t) + xnrm2;
            END_IF;

            k := k + 1;
        END_WHILE;
        xnrm2 := scale * SQRT(xnrm2);
    END_IF;

END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xnrm2_j" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="scale">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="kend">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="absxk">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="t">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
xnrm2_j := 0.0;

IF b_n >= 1 THEN 

    IF b_n = 1 THEN 
        xnrm2_j := ABS(x[ix0 - 1]);
    ELSE 
        scale := 3.3121686421112381E-170;
        kend := (ix0 + b_n) - 1;
        k := ix0;
        WHILE k <= kend DO
            absxk := ABS(x[k - 1]);

            IF absxk > scale THEN 
                t := scale / absxk;
                xnrm2_j := ((xnrm2_j * t) * t) + 1.0;
                scale := absxk;
            ELSE 
                t := absxk / scale;
                xnrm2_j := (t * t) + xnrm2_j;
            END_IF;

            k := k + 1;
        END_WHILE;
        xnrm2_j := scale * SQRT(xnrm2_j);
    END_IF;

END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xscal" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="b">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
b := (ix0 + b_n) - 1;
k := ix0;
WHILE k <= b DO
    x[k - 1] := x[k - 1] * a;
    k := k + 1;
END_WHILE;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xscal_f" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="b">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
b := (ix0 + b_n) - 1;
k := ix0;
WHILE k <= b DO
    x[k - 1] := x[k - 1] * a;
    k := k + 1;
END_WHILE;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xaxpy_po" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="5"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="y">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="ix">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

IF (b_n >= 1) AND (a <> 0.0) THEN 
    ix := ix0 - 1;
    iy := iy0 - 1;
    k := 0;
    WHILE k <= (b_n - 1) DO
        y[iy] := (a * x[ix]) + y[iy];
        ix := ix + 1;
        iy := iy + 1;
        k := k + 1;
    END_WHILE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xaxpy_p" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="y">
              <type>
                <array>
                  <dimension lower="0" upper="5"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="ix">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

IF (b_n >= 1) AND (a <> 0.0) THEN 
    ix := ix0 - 1;
    iy := iy0 - 1;
    k := 0;
    WHILE k <= (b_n - 1) DO
        y[iy] := (a * x[ix]) + y[iy];
        ix := ix + 1;
        iy := iy + 1;
        k := k + 1;
    END_WHILE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xaxpy" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="y">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="ix">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

IF (b_n >= 1) AND (a <> 0.0) THEN 
    ix := ix0 - 1;
    iy := iy0 - 1;
    k := 0;
    WHILE k <= (b_n - 1) DO
        y[iy] := (a * y[ix]) + y[iy];
        ix := ix + 1;
        iy := iy + 1;
        k := k + 1;
    END_WHILE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xaxpy_poj" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="y">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="ix">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

IF (b_n >= 1) AND (a <> 0.0) THEN 
    ix := ix0 - 1;
    iy := iy0 - 1;
    k := 0;
    WHILE k <= (b_n - 1) DO
        y[iy] := (a * y[ix]) + y[iy];
        ix := ix + 1;
        iy := iy + 1;
        k := k + 1;
    END_WHILE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xscal_fb" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
k := ix0;
WHILE k <= (ix0 + 5) DO
    x[k - 1] := x[k - 1] * a;
    k := k + 1;
END_WHILE;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xscal_fbq" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
k := ix0;
WHILE k <= (ix0 + 4) DO
    x[k - 1] := x[k - 1] * a;
    k := k + 1;
END_WHILE;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xswap" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="temp">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="tmp">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

FOR k := 0 TO 4 DO 
    temp_tmp := (ix0 + k) - 1;
    temp := x[temp_tmp];
    tmp := (iy0 + k) - 1;
    x[temp_tmp] := x[tmp];
    x[tmp] := temp;
END_FOR;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xswap_k" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="temp">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="tmp">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

FOR k := 0 TO 5 DO 
    temp_tmp := (ix0 + k) - 1;
    temp := x[temp_tmp];
    tmp := (iy0 + k) - 1;
    x[temp_tmp] := x[tmp];
    x[tmp] := temp;
END_FOR;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xrot" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="c">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b_s">
              <type>
                <LREAL/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp_0">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp_tmp_1">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp_2">
              <type>
                <LREAL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

FOR k := 0 TO 4 DO 
    temp_tmp := (iy0 + k) - 1;
    temp_tmp_0 := x[temp_tmp];
    temp_tmp_1 := (ix0 + k) - 1;
    temp_tmp_2 := x[temp_tmp_1];
    x[temp_tmp] := (temp_tmp_0 * c) - (temp_tmp_2 * b_s);
    x[temp_tmp_1] := (temp_tmp_2 * c) + (temp_tmp_0 * b_s);
END_FOR;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xrotg" pouType="functionBlock">
        <interface>
          <inputVars/>
          <outputVars>
            <variable name="c">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b_s">
              <type>
                <LREAL/>
              </type>
            </variable>
          </outputVars>
          <inOutVars>
            <variable name="a">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b">
              <type>
                <LREAL/>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="roe">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="absa">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="absb">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="scale">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ads">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="bds">
              <type>
                <LREAL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
roe := b;
absa := ABS(a);
absb := ABS(b);

IF absa > absb THEN 
    roe := a;
END_IF;

scale := absa + absb;

IF scale = 0.0 THEN 
    b_s := 0.0;
    c := 1.0;
    a := 0.0;
    b := 0.0;
ELSE 
    ads := absa / scale;
    bds := absb / scale;
    scale := SQRT((ads * ads) + (bds * bds)) * scale;

    IF roe < 0.0 THEN 
        scale :=  -scale;
    END_IF;

    c := a / scale;
    b_s := b / scale;

    IF absa > absb THEN 
        b := b_s;
    ELSIF c <> 0.0 THEN 
        b := 1.0 / c;
    ELSE 
        b := 1.0;
    END_IF;

    a := scale;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xrot_l" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="c">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b_s">
              <type>
                <LREAL/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp_0">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="temp_tmp_1">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp_tmp_2">
              <type>
                <LREAL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

FOR k := 0 TO 5 DO 
    temp_tmp := (iy0 + k) - 1;
    temp_tmp_0 := x[temp_tmp];
    temp_tmp_1 := (ix0 + k) - 1;
    temp_tmp_2 := x[temp_tmp_1];
    x[temp_tmp] := (temp_tmp_0 * c) - (temp_tmp_2 * b_s);
    x[temp_tmp_1] := (temp_tmp_2 * c) + (temp_tmp_0 * b_s);
END_FOR;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xzlascl_g" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="cfrom">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="cto">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="m">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iA0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="lda">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="A">
              <type>
                <array>
                  <dimension lower="0" upper="4"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="cfromc">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ctoc">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="notdone">
              <type>
                <BOOL/>
              </type>
            </variable>
            <variable name="cfrom1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="cto1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b_mul">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="offset">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="j">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp1">
              <type>
                <BOOL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
cfromc := cfrom;
ctoc := cto;
notdone := TRUE;
WHILE notdone DO
    cfrom1 := cfromc * 2.0041683600089728E-292;
    cto1 := ctoc / 4.9896007738368E+291;
    temp1 := FALSE;

    IF ABS(cfrom1) > ABS(ctoc) THEN 

        IF ctoc <> 0.0 THEN 
            b_mul := 2.0041683600089728E-292;
            cfromc := cfrom1;
        ELSE 
            temp1 := TRUE;
        END_IF;

    ELSE 
        temp1 := TRUE;
    END_IF;


    IF temp1 THEN 

        IF ABS(cto1) > ABS(cfromc) THEN 
            b_mul := 4.9896007738368E+291;
            ctoc := cto1;
        ELSE 
            b_mul := ctoc / cfromc;
            notdone := FALSE;
        END_IF;

    END_IF;

    j := 0;
    WHILE j <= (b_n - 1) DO
        offset := ((j * lda) + iA0) - 2;
        i := 1;
        WHILE (i - 1) <= (m - 1) DO
            tmp := offset + i;
            A[tmp] := A[tmp] * b_mul;
            i := i + 1;
        END_WHILE;
        j := j + 1;
    END_WHILE;
END_WHILE;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xzlascl" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="cfrom">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="cto">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="m">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iA0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="lda">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <outputVars/>
          <inOutVars>
            <variable name="A">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="cfromc">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="ctoc">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="notdone">
              <type>
                <BOOL/>
              </type>
            </variable>
            <variable name="cfrom1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="cto1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b_mul">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="offset">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="j">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="tmp">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="temp1">
              <type>
                <BOOL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
cfromc := cfrom;
ctoc := cto;
notdone := TRUE;
WHILE notdone DO
    cfrom1 := cfromc * 2.0041683600089728E-292;
    cto1 := ctoc / 4.9896007738368E+291;
    temp1 := FALSE;

    IF ABS(cfrom1) > ABS(ctoc) THEN 

        IF ctoc <> 0.0 THEN 
            b_mul := 2.0041683600089728E-292;
            cfromc := cfrom1;
        ELSE 
            temp1 := TRUE;
        END_IF;

    ELSE 
        temp1 := TRUE;
    END_IF;


    IF temp1 THEN 

        IF ABS(cto1) > ABS(cfromc) THEN 
            b_mul := 4.9896007738368E+291;
            ctoc := cto1;
        ELSE 
            b_mul := ctoc / cfromc;
            notdone := FALSE;
        END_IF;

    END_IF;

    j := 0;
    WHILE j <= (b_n - 1) DO
        offset := ((j * lda) + iA0) - 2;
        i := 1;
        WHILE (i - 1) <= (m - 1) DO
            tmp := offset + i;
            A[tmp] := A[tmp] * b_mul;
            i := i + 1;
        END_WHILE;
        j := j + 1;
    END_WHILE;
END_WHILE;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xdotc" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="y">
              <type>
                <array>
                  <dimension lower="0" upper="29"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="ix">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
xdotc := 0.0;

IF b_n >= 1 THEN 
    ix := ix0;
    iy := iy0;
    k := 0;
    WHILE k <= (b_n - 1) DO
        xdotc := (x[ix - 1] * y[iy - 1]) + xdotc;
        ix := ix + 1;
        iy := iy + 1;
        k := k + 1;
    END_WHILE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="xdotc_d" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="b_n">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="x">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="ix0">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="y">
              <type>
                <array>
                  <dimension lower="0" upper="24"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="iy0">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="ix">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="iy">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="k">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
xdotc_d := 0.0;

IF b_n >= 1 THEN 
    ix := ix0;
    iy := iy0;
    k := 0;
    WHILE k <= (b_n - 1) DO
        xdotc_d := (x[ix - 1] * y[iy - 1]) + xdotc_d;
        ix := ix + 1;
        iy := iy + 1;
        k := k + 1;
    END_WHILE;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="rt_floord" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="u">
              <type>
                <LREAL/>
              </type>
            </variable>
          </inputVars>
          <localVars/>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
rt_floord := DINT_TO_LREAL(TRUNC(u));

IF u = rt_floord THEN 
    rt_floord := u;
ELSIF u < 0.0 THEN 
    rt_floord := rt_floord - 1.0;
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="rt_ldexp_U1d_U2s32_Yd_s_pw" pouType="function">
        <interface>
          <returnType>
            <LREAL/>
          </returnType>
          <inputVars>
            <variable name="u0">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="u1">
              <type>
                <DINT/>
              </type>
            </variable>
          </inputVars>
          <localVars/>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

IF (u0 = 0.0) OR (u1 = 0) THEN 
    rt_ldexp_U1d_U2s32_Yd_s_pw := u0;
ELSE 
    rt_ldexp_U1d_U2s32_Yd_s_pw := u0 * EXPT(2.0, DINT_TO_LREAL(u1));
END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="eye" pouType="functionBlock">
        <interface>
          <inputVars/>
          <outputVars>
            <variable name="I">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="b_i">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[

FOR b_i := 0 TO 8 DO 
    I[b_i] := 0.0;
END_FOR;

I[0] := 1.0;
I[4] := 1.0;
I[8] := 1.0;

]]></xhtml>
          </ST>
        </body>
      </pou>
      <pou name="MatrixLog3" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="b_R">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="so3mat">
              <type>
                <array>
                  <dimension lower="0" upper="8"/>
                  <baseType>
                    <LREAL/>
                  </baseType>
                </array>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="acosinput">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="theta">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="t">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="i">
              <type>
                <DINT/>
              </type>
            </variable>
            <variable name="b_idx_0">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="b_idx_1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="so3mat_tmp">
              <type>
                <DINT/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
(* 'MatrixLog3:18' acosinput = (trace(R) - 1) / 2; *)
acosinput := (((b_R[0] + b_R[4]) + b_R[8]) - 1.0) / 2.0;
(* 'MatrixLog3:19' if acosinput >= 1 *)

IF acosinput >= 1.0 THEN 
    (* 'MatrixLog3:20' so3mat = zeros(3); *)

    FOR i := 0 TO 8 DO 
        so3mat[i] := 0.0;
    END_FOR;

ELSIF acosinput <= -1.0 THEN 
    (* 'MatrixLog3:21' elseif acosinput <= -1 *)
    (* 'MatrixLog3:22' if ~NearZero(1 + R(3, 3)) *)
    (* *** BASIC HELPER FUNCTIONS *** *)
    (* Takes a scalar. *)
    (* Checks if the scalar is small enough to be neglected. *)
    (* Example Input: *)
    
    (* clear; clc; *)
    (* near = -1e-7; *)
    (* judge = NearZero(near) *)
    
    (* Output: *)
    (* judge = *)
    (* 1 *)
    (* 'NearZero:15' judge = norm(near) < 1e-6; *)

    IF ABS(b_R[8] + 1.0) >= 1.0E-6 THEN 
        (* 'MatrixLog3:23' omg = (1 / sqrt(2 * (1 + R(3, 3)))) ... *)
        (* 'MatrixLog3:24'               * [R(1, 3); R(2, 3); 1 + R(3, 3)]; *)
        t := 1.0 / SQRT((b_R[8] + 1.0) * 2.0);
        b_idx_0 := t * b_R[6];
        b_idx_1 := t * b_R[7];
        t := (b_R[8] + 1.0) * t;
    ELSE 
        (* *** BASIC HELPER FUNCTIONS *** *)
        (* Takes a scalar. *)
        (* Checks if the scalar is small enough to be neglected. *)
        (* Example Input: *)
        
        (* clear; clc; *)
        (* near = -1e-7; *)
        (* judge = NearZero(near) *)
        
        (* Output: *)
        (* judge = *)
        (* 1 *)
        (* 'NearZero:15' judge = norm(near) < 1e-6; *)

        IF ABS(b_R[4] + 1.0) >= 1.0E-6 THEN 
            (* 'MatrixLog3:25' elseif ~NearZero(1 + R(2, 2)) *)
            (* 'MatrixLog3:26' omg = (1 / sqrt(2 * (1 + R(2, 2)))) ... *)
            (* 'MatrixLog3:27'               * [R(1, 2); 1 + R(2, 2); R(3, 2)]; *)
            t := 1.0 / SQRT((b_R[4] + 1.0) * 2.0);
            b_idx_0 := t * b_R[3];
            b_idx_1 := (b_R[4] + 1.0) * t;
            t := t * b_R[5];
        ELSE 
            (* 'MatrixLog3:28' else *)
            (* 'MatrixLog3:29' omg = (1 / sqrt(2 * (1 + R(1, 1)))) ... *)
            (* 'MatrixLog3:30'               * [1 + R(1, 1); R(2, 1); R(3, 1)]; *)
            t := 1.0 / SQRT((b_R[0] + 1.0) * 2.0);
            b_idx_0 := (b_R[0] + 1.0) * t;
            b_idx_1 := t * b_R[1];
            t := t * b_R[2];
        END_IF;

    END_IF;

    (* 'MatrixLog3:32' so3mat = VecToso3(pi * omg); *)
    b_idx_0 := 3.1415926535897931 * b_idx_0;
    b_idx_1 := 3.1415926535897931 * b_idx_1;
    t := 3.1415926535897931 * t;
    (* *** CHAPTER 3: RIGID-BODY MOTIONS *** *)
    (* Takes a 3-vector (angular velocity). *)
    (* Returns the skew symmetric matrix in so(3). *)
    (* Example Input: *)
    
    (* clear; clc; *)
    (* omg = [1; 2; 3]; *)
    (* so3mat = VecToso3(omg) *)
    
    (* Output: *)
    (* so3mat = *)
    (* 0    -3     2 *)
    (* 3     0    -1 *)
    (* -2     1     0 *)
    (* 'VecToso3:17' so3mat = [0, -omg(3), omg(2); omg(3), 0, -omg(1); -omg(2), omg(1), 0]; *)
    so3mat[0] := 0.0;
    so3mat[3] :=  -t;
    so3mat[6] := b_idx_1;
    so3mat[1] := t;
    so3mat[4] := 0.0;
    so3mat[7] :=  -b_idx_0;
    so3mat[2] :=  -b_idx_1;
    so3mat[5] := b_idx_0;
    so3mat[8] := 0.0;
ELSE 
    (* 'MatrixLog3:33' else *)
    (* 'MatrixLog3:34' theta = acos(acosinput); *)
    theta := ACOS(acosinput);
    (* 'MatrixLog3:35' so3mat = theta * (1 / (2 * sin(theta))) * (R - R'); *)
    t := (1.0 / (2.0 * SIN(theta))) * theta;

    FOR i := 0 TO 2 DO 
        so3mat[3 * i] := (b_R[3 * i] - b_R[i]) * t;
        so3mat_tmp := (3 * i) + 1;
        so3mat[so3mat_tmp] := (b_R[so3mat_tmp] - b_R[i + 3]) * t;
        so3mat_tmp := (3 * i) + 2;
        so3mat[so3mat_tmp] := (b_R[so3mat_tmp] - b_R[i + 6]) * t;
    END_FOR;

END_IF;


]]></xhtml>
          </ST>
        </body>
      </pou>
    </pous>
  </types>
  <instances>
    <configurations>
      <configuration name="Configuration">
        <resource name="RedCrane_kinematic_model_telescope_res">
          <globalVars constant="true">
            <variable name="SS_INITIALIZE">
              <type>
                <SINT/>
              </type>
              <initialValue>
                <simpleValue value="0"/>
              </initialValue>
            </variable>
            <variable name="SS_STEP">
              <type>
                <SINT/>
              </type>
              <initialValue>
                <simpleValue value="1"/>
              </initialValue>
            </variable>
          </globalVars>
        </resource>
      </configuration>
    </configurations>
  </instances>
</project>
